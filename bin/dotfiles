#!/usr/bin/env bash

# Copyright (c) 2012 "Cowboy" Ben Alman
# Licensed under the MIT license.
# http://benalman.com/about/license/

declare -r SCRIPT_PATH="${BASH_SOURCE[0]}"
declare -r SCRIPT_BASENAME="${SCRIPT_PATH##*/}"
declare -r SCRIPT_DIRNAME="${SCRIPT_PATH%/*}"

declare -x DOTFILES_ROOT="${DOTFILES_ROOT:=$(readlink -e "${SCRIPT_DIRNAME}/../.dotfiles")}"

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
explode_bash_version () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local major_ver minor_ver trailing build revision
    IFS=$'.' read -r major_ver minor_ver trailing <<<"$BASH_VERSION"
    if [[ "$trailing" =~ ([[:digit:]]+)\(([[:digit:]]+)\) ]]; then
        build="${BASH_REMATCH[1]}"
        revision="${BASH_REMATCH[2]}"
    fi
    echo "$major_ver" "$minor_ver" "$build" "$revision"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Logging stuff
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if [[ "$(locale charmap)" =~ UTF-8 ]]; then
    e_header ()   { printf "\n\033[1;35m★★★★★\033[0m %b \033[1;35m★★★★★\033[0m\n\n" "$@"; }
    e_prompt ()   { printf "\n \033[1;37m☛\033[0m %b " "$@"; }
    e_success ()  { printf " \033[1;32m✔\033[0m %b\n" "$@"; }
    e_error ()    { printf " \033[1;31m✖\033[0m %b\n" "$@"; }
    e_fatal ()    { printf " \033[1;31m☠\033[0m %b\n" "$@"; }
    e_arrow ()    { printf " \033[1;33m➜\033[0m %b\n" "$@"; }
else
    e_header ()   { printf "\n\033[1;35m=====\033[0m %b \033[1;35m=====\033[0m\n\n" "$@"; }
    e_prompt ()   { printf "\n \037[1;35m?\033[0m %b " "$@"; }
    e_success ()  { printf " \033[1;32m:)\033[0m %b\n" "$@"; }
    e_error ()    { printf " \033[1;31m:(\033[0m %b\n" "$@"; }
    e_fatal ()    { printf " \033[1;31m:S\033[0m %b\n" "$@"; }
    e_arrow ()    { printf " \033[1;33m->\033[0m %b\n" "$@"; }
fi


# Given a list of desired items and installed items, return a list
# of uninstalled items. Arrays in bash are insane (not in a good way).
to_install () {
    local debug desired installed i desired_s installed_s remain
    if [[ "$1" == 1 ]]; then debug=1; shift; fi
    # Convert args to arrays, handling both space- and newline-separated lists.
    local -a desired=("$1")
    local -a installed=("$2")
    #read -ra desired < <(echo "$1" | tr '\n' ' ')
    #read -ra installed < <(echo "$2" | tr '\n' ' ')
    # Sort desired and installed arrays.
    unset i; while read -r; do desired_s[i++]=$REPLY; done < <(
        printf "%s\n" "${desired[@]}" | sort
    )
    unset i; while read -r; do installed_s[i++]=$REPLY; done < <(
        printf "%s\n" "${installed[@]}" | sort
    )
    # Get the difference. comm is awesome.
    unset i; while read -r; do remain[i++]=$REPLY; done < <(
        comm -13 <(printf "%s\n" "${installed_s[@]}") <(printf "%s\n" "${desired_s[@]}")
    )
    [[ "$debug" ]] && for v in desired desired_s installed installed_s remain; do
        echo "$v ($(eval echo "\${#$v[*]}")) $(eval echo "\${$v[*]}")"
    done
    echo "${remain[@]}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skip () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Offer the user a chance to skip something.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local REPLY=noskip
    read -t 5 -n 1 -s -p "$(e_prompt "To skip, press X within 5 seconds.")"
    if [[ "$REPLY" =~ ^[Xx]$ ]]; then
        echo "Skipping!"
        return 0
    else
        echo "Continuing..."
        return 1
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_do() {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Initialize
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    e_header "Sourcing ${srcfile}"
    source "$srcfile"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy_header () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    e_header "Copying files into ${DOTFILES_DESTDIR}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy_test () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Ensures that files in the destination aren't overwritten if either
#   - The destination file is exactly the same as the source file; or
#   - The destination file is newer than the source file.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local maybe_destfile="$1"
    local destfile

    destfile="$(check_noclobber "$maybe_destfile")"

    if [[ -e "${destfile}" && ! "$(cmp "${srcfile}" "${destfile}" 2> /dev/null)" ]]; then
        echo "same file"
        return 1
    elif [[ "$1" -ot "$2" ]]; then
        echo "destination file newer"
        return 1
    fi

    return 0
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy_do () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Attempts to copy a file, printing pretty output
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"
    local destdir="${destfile%/*}"

    if ! mkdir -p "$destdir" >/dev/null; then
        e_error "Can't copy ${srcfile} to ${destfile}"
        return 1
    fi

    if ! cp "$srcfile" "$destfile"; then
        e_error "Failed to copy ${srcfile} to ${destfile}"
        return 1
    else
        e_success "Copied ${srcfile} to ${destfile}"
        return 0
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skel_header () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    e_header "Copying skeleton files into ${DOTFILES_DESTDIR}";
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skel_test () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# More restrictive than copy_test: if the destination file exists at all, don't
# overwrite it.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"

    if [[ -e "$destfile" ]]; then
        echo "destination file already exists"
        return 1
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skel_do () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Just another name for copy_do
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    copy_do "$@"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
link_header () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    e_header "Linking files into ${DOTFILES_DESTDIR}";
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
link_test () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"

    if [[ "${srcfile}" -ef "${destfile}" ]]; then
        echo "link already exists"
        return 0
    fi

    return 1
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_noclobber () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$1"
    local real_destfile="$destfile"

    if "${DOTFILES_NOCLOBBER}"; then
        if [[ "${__DOTFILES_NOCLOBBER_RC_MAP["${destfile#$DOTFILES_DESTDIR}"]:-false}" == 'true' ]]; then
            e_arrow "Not clobbering ${destfile};" \
                "${srcfile} will be appended with '${DOTFILES_NOCLOBBER_EXT}'" 1>&2
            real_destfile="${destfile}${DOTFILES_NOCLOBBER_EXT}"
        fi
    fi

    echo "$real_destfile"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
link_do () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local maybe_destfile="$2"
    local destfile

    destfile="$(check_noclobber "$maybe_destfile")"
    local destdir="${destfile%/*}"

    if ! mkdir -p "$destdir" >/dev/null; then
        e_error "Can't link ${destfile} to ${srcfile}"
        return 1
    fi

    ln -sf "$srcfile" "$destfile"
    e_success "Linking ${srcfile} to ${destfile}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
md5cmp () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Minimize dependencies: cmp is in diffutils, md5sum is in coreutils.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local left right leftsumout rightsumout

    left="$1"
    right="$2"

    leftsumout="$(md5sum "$left")"
    rightsumout="$(md5sum "$right")"

    [[ "${leftsumout%% *}" == "${rightsumout%% *}" ]]
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
splitfile () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local file="$1"
    local prefix="$2"
    local relpath="${file##$prefix}"
    local -a path_elements
    local IFS=$'/'
    read -ra path_elements <<<"$relpath"
    unset IFS
    # Necessary in order to get rid of the leading trailing space
    echo "${path_elements[@]:1}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
find_hierarchical () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local targetdir="$1"
    shift
    local prefix

    local opt_name opt_arg remain
    while (( $# )); do
        read -r opt_name opt_arg remain <<<"$@"
        case "$opt_name" in
		-p|--prefix)
			prefix="$opt_arg"
			shift 2
			break
			;;
		*)
			continue
			;;
	esac
    done

    local IFS
    while read -ra path_elements; do
        IFS=$'/'
        echo "${prefix}${prefix:+/}${path_elements[*]}"
        unset IFS
    done < <(sort -n < <(while read -r target; do
        splitfile "$target" "$prefix"
    done < <(find "$targetdir" "$@")))
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
do_stuff () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Copy, link, init, etc.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optype srcdir_relpath srcdir

    # Little trick: this makes both 'do_stuff "link"' and 'do_stuff "opt/link"'
    # work as expected.
    srcdir_relpath="$1"
    optype="${srcdir_relpath##*/}"
    if [[ -z "$optype" ]]; then
        e_error "No optype specified" 1>&2
        return 1
    fi

    local optype_do="${optype}_do"
    # Silently ignore any operation types that haven't been declared.
    if ! declare -F "$optype_do" &>/dev/null; then
        return 0
    fi

    srcdir="${DOTFILES_ROOT}/${srcdir_relpath}"
    if ! [[ -d "$srcdir" ]]; then
        e_error "No such directory: $srcdir" 1>&2
        return 1
    fi

    # Run _header function only if declared.
    local optype_header="${optype}_header"
    declare -F "$optype_header" &>/dev/null && "$optype_header"

    # Run _test function only if declared.
    local test_func="${optype}_test"

    # Iterate over files.
    local skip_reason srcfile srcstem destfile backup_subpath
    local -i failed=0
    while read -r srcfile; do
        # Don't quite know why this is necessary -- 'find' sometimes strips the
        # leading slash when called using process substitution...
        # Because find returns absolute paths, it's probably (?) safe to just
        # append a leading slash.
        [[ "$srcfile" =~ ^/ ]] || srcfile="/${srcfile}"

        srcstem="${srcfile#$srcdir/}"
        destfile="${DOTFILES_DESTDIR}/${srcstem}"

        if declare -f "$test_func" &>/dev/null; then
            # If _test function returns a string, skip file and print that
            # message.
            skip_reason="$("$test_func" "$srcfile" "$destfile")"
            if [[ -n "$skip_reason" ]]; then
                e_error "Skipping ${srcstem}: ${skip_reason}" 1>&2
                continue
            fi

            # Destination file already exists in ~/. Back it up!
            if [[ -e "$destfile" ]]; then
                e_arrow "Backing up ${destfile}."
                # Set backup flag, so a nice message can be shown at the end.
                ((__DOTFILES_BACKUP++))

                backup_subpath="${DOTFILES_BACKUP_PATH}/${destfile%/*}"
                # Create backup dir if it doesn't already exist.
                if ! [[ -e "$backup_subpath" ]]; then
                    if ! mkdir -p "$backup_subpath" &>/dev/null; then
                        e_fatal "Could not create backup directory" \
                            "${backup_subpath}; exiting".
                        exit 1
                    fi
                elif ! [[ -d "$backup_subpath" ]]; then
                    e_error "${backup_subpath} exists but is not a directory" 1>&2
                    ((failed++))
                    ((__DOTFILES_FAILED++))
                fi

                cp "$destfile" "$backup_subpath"
            fi
        fi

        # Do stuff.
        "$optype_do" "$srcfile" "$destfile"
    done < <(find_hierarchical "$srcdir" --prefix "$DOTFILES_ROOT" -xtype f)

    [[ $failed -eq 0 ]]
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
do_opt_stuff () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Iterate through directories in .dotfiles/opt,
# prompting user whether or not to process them.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcdir_relpath="$1"

    if [[ -d "${DOTFILES_ROOT}/${srcdir_relpath}" ]]; then
        local do_process
        read -N 1 -t 15 -p "$(e_prompt "Process optional ${srcdir_relpath##*/} files? [y/N]") " do_process
        echo

        if [[ "$do_process" =~ [Yy] ]]; then
            do_stuff "$srcdir_relpath"
        fi
    fi

    return 0
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_dotfiles() {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    [[ $DOTFILES_SKIP_INIT == 'true' ]] && return 0

    # Skip this function after we exec the updated version of this script.
    export DOTFILES_SKIP_INIT=true

    if ! [[ -d $DOTFILES_ROOT ]]; then
        # If the root directory doesn't exist, treat this as a new
        # installation.
        export DOTFILES_NEW_INSTALL=true
        e_header "Downloading dotfiles"
        git clone --recursive "$DOTFILES_REPO" "$DOTFILES_ROOT"
    else
        # Make sure we have the latest files.
        e_header "Updating dotfiles"

        pushd "$DOTFILES_ROOT" >/dev/null

        local prev_head
        prev_head="$(git rev-parse HEAD)"

        git pull

        if ! git submodule update --init --recursive --quiet; then
        e_error "Failed to update git submodules." \
            "This probably requires your intervention." 1>&2
        fi

        local current_head
        current_head="$(git rev-parse HEAD)"

        popd >/dev/null

        if [[ "$current_head" != "$prev_head" ]]; then
            e_header "Executing updated ${SCRIPT_BASENAME} script"
            exec "${SCRIPT_PATH}"
        fi
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
usage () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -i return_code=${1:-0}
    [[ "$return_code" -ne 0 ]] && echo "Usage: $SCRIPT_BASENAME [-n] [-c] [-h]"
    cat <<EOF

See the README for documentation. https://github.com/cowboy/dotfiles

Copyright (c) 2012 "Cowboy" Ben Alman Licensed under the MIT license.
http://benalman.com/about/license/

EOF
    return "$return_code"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Grab command-line options
    if [[ -z $DOTFILES_VERSION ]] \
        || awk -v n1="$DOTFILES_VERSION" n2='1.0' \
        'BEGIN{if(n2<n1)exit 0;exit 1}' &>/dev/null; then
        e_fatal "You are running an old version of dotfiles.  Old options may" \
            "nolonger work.  Please run 'dotfiles --help' to view usage."
        exit 1
    fi

    local bash_major_ver
    read -r bash_major_ver _ <<<"$(explode_bash_version)"

    if [[ $bash_major_ver -lt 3 ]]; then
        e_fatal "You are using an ancient Bash version ($BASH_VERSION)." \
            "Please upgrade."
        exit 1
    elif [[ $bash_major_ver -lt 4 ]]; then
        e_fatal "Your Bash version ($BASH_VERSION) doesn't support associative arrays." \
            "Please upgrade."
        exit 1
    fi

    local opt_name opt_value
    while (( $# )); do
        read opt_name opt_value <<<"$@"
        case "$opt_name" in
            -n|--new-install)
                DOTFILES_NEW_INSTALL=true
                shift
                ;;
            -s|--skip-init)
                DOTFILES_SKIP_INIT=true
                shift
                ;;
            -c|--clobber)
                DOTFILES_NOCLOBBER=false
                shift
                ;;
            -P|--preserve)
                DOTFILES_NOCLOBBER_RCS="$opt_value"
                shift 2
                ;;
            -B|--backup-path)
                DOTFILES_BACKUP_PATH="$opt_value"
                shift 2
                ;;
            -C|--cache-path)
                DOTFILES_CACHE_PATH="$opt_value"
                shift 2
                ;;
            -v|--verbose)
                DOTFILES_VERBOSE=true
                shift
                ;;
            -q|--quiet)
                DOTFILES_VERBOSE=false
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                echo "Invalid option: ${opt_name}" 1>&2
                usage 1
                exit $?
                ;;
        esac
    done

    # Initial stuff; do only if we haven't updated to the newest version
    if ! [[ "$DOTFILES_SKIP_INIT" == 'true' ]]; then
        usage

        e_header "Performing initial configuration"

        # Ensure that we can actually, like, compile anything.
        if ! command -v gcc >/dev/null 2>&1 && [[ "$OSTYPE" =~ ^darwin ]]; then
            e_fatal "XCode or the Command Line Tools for XCode must be installed first." 1>&2
            exit 1
        fi

        # If Git is not installed, install it (Ubuntu only, since Git comes
        # standard with recent XCode or CLT)
        if ! type -P git >/dev/null 2>&1; then
            e_fatal "Git should be installed. It isn't. Aborting." 1>&2
            exit 1
        fi

        # Update existing sudo time stamp if set, otherwise do nothing.
        while true; do
            sudo -n true
            sleep 60
            kill -0 "$$" || exit
        done 2>/dev/null &

        # Initialize.
        e_header "Pulling in updated dotfiles repo"
        init_dotfiles
    else
        e_header "Skipping initialization"
    fi

    "${DOTFILES_NOCLOBBER}" \
        && e_header "Preserving some existing configurations"

    # Add binaries into the path
    PATH="${DOTFILES_ROOT}/bin${PATH:+:}${PATH}"
    export PATH

    # Create caches directory, if it doesn't already exist.
    mkdir -p "$DOTFILES_CACHE_PATH"

    # Execute code for each file in these subdirectories.
    local dotfiles_subdir
    for dotfiles_subdir in "$DOTFILES_ROOT"/*; do
        optype="${dotfiles_subdir##*/}"
        declare -F "${optype}_do" &>/dev/null || continue
        do_stuff "$optype"
        [[ -d "${DOTFILES_ROOT}/opt/${optype}" ]] && do_opt_stuff "$optype"
    done

    # Alert if backups were made.
    if [[ "$__DOTFILES_BACKUP" -gt 0 ]]; then
        e_arrow "\nBackups were moved to ${DOTFILES_BACKUP_PATH}\n"
    fi

    # Lest I forget to do a few additional things...
    if "${DOTFILES_NEW_INSTALL}" && [[ -f "conf/firsttime_reminder.sh" ]]; then
        e_header "This is a new installation"
        e_header "First-Time Reminders"
        source "conf/firsttime_reminder.sh"
    fi

    # All done!
    e_header "All done!"
    return 0
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    # Don't allow unset variables or uncaught errors
    set -o nounset

    # Tweak file globbing.
    shopt -s dotglob
    shopt -s nullglob


    # Globals
    DOTFILES_VERSION="${DOTFILES_VERSION:-1.0}"
    DOTFILES_BACKUP_PATH="${DOTFILES_BACKUP_PATH:=${DOTFILES_ROOT}/backup/$(date "+%Y_%m_%d-%H_%M_%S")}"
    DOTFILES_CACHE_PATH="${DOTFILES_CACHE_PATH:=${DOTFILES_ROOT}/caches}"
    DOTFILES_DESTDIR="${DOTFILES_DESTDIR:=$HOME}"
    DOTFILES_NEW_INSTALL="${DOTFILES_NEW_INSTALL:=false}"
    DOTFILES_REPO="${DOTFILES_REPO:=git://github.com/BaxterStockman/dotfiles.git}"
    DOTFILES_SKIP_INIT="${DOTFILES_SKIP_INIT:=false}"
    DOTFILES_NOCLOBBER="${DOTFILES_NOCLOBBER:=true}"
    DOTFILES_VERBOSE="${DOTFILES_VERBOSE:=true}"
    DOTFILES_NOCLOBBER_EXT="${DOTFILES_NOCLOBBER_EXT:-.custom}"
    DOTFILES_NOCLOBBER_RCS="${DOTFILES_NOCLOBBER_RCS:-}"

    declare -i __DOTFILES_BACKUP=0
    declare -i __DOTFILES_FAILED=0

    declare -A __DOTFILES_NOCLOBBER_RC_MAP
    # RC files to not clobber when linking
    if [[ -n "$DOTFILES_NOCLOBBER_RCS" ]]; then
        IFS=$','
        for rc in $DOTFILES_NOCLOBBER_RCS; do
            __DOTFILES_NOCLOBBER_RC_MAP["$rc"]=true
        done
        unset IFS rc
    else
        __DOTFILES_NOCLOBBER_RC_MAP=(
            ['.bashrc']=true
            ['.bash_login']=true
            ['.bash_logout']=true
            ['.bash_profile']=true
            ['.muttrc']=true
            ['.subversion']=true
            ['.perlbrew']=true
            ['.ssh']=true
        )
        IFS=$','
        export DOTFILES_NOCLOBBER_RCS="${!__DOTFILES_NOCLOBBER_RC_MAP[*]}"
        unset IFS
    fi

    # Enough with the functions, let's do stuff.
    main "$@"
fi
