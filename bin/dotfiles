#!/usr/bin/env bash

# Copyright (c) 2012 "Cowboy" Ben Alman
# Licensed under the MIT license.
# http://benalman.com/about/license/

SCRIPT_PATH="${BASH_SOURCE[0]}"
SCRIPT_BASENAME="${SCRIPT_PATH##*/}"
SCRIPT_DIRNAME="${SCRIPT_PATH%/*}"

# Globals
DOTFILES_ROOT="${DOTFILES_ROOT:-"$(readlink -e "${SCRIPT_DIRNAME}/../.dotfiles")"}"
DOTFILES_REPO="${DOTFILES_REPO:-git://github.com/BaxterStockman/dotfiles.git}"

# Global flow control flags
DOTFILES_NEW_INSTALL="${DOTFILES_NEW_INSTALL:-false}"
DOTFILES_SKIP_INIT="${DOTFILES_SKIP_INIT:-false}"
DOTFILES_NOCLOBBER="${DOTFILES_NOCLOBBER:-true}"

DOTFILES_VERBOSE="${DOTFILES_VERBOSE:-true}"

# Flags for whether to print link/copy/etc. optypes
print_copy_header=true
print_skel_header=true
print_link_header=true

# Flag for whether to print help doc
print_help=false

# RC files to not clobber when linking
declare -a DOTFILES_NOCLOBBER_RCS=(
    bashrc
    bash_login
    bash_logout
    bash_profile
    muttrc
    subversion
    perlbrew
    ssh
)

# Logging stuff.
function e_header()   { echo -e "\n\033[1m$*\033[0m"; }
function e_success()  { echo -e " \033[1;32m✔\033[0m  $*"; }
function e_error()    { echo -e " \033[1;31m✖\033[0m  $*"; }
function e_arrow()    { echo -e " \033[1;33m➜\033[0m  $*"; }

# Given a list of desired items and installed items, return a list
# of uninstalled items. Arrays in bash are insane (not in a good way).
function to_install() {
    local debug desired installed i desired_s installed_s remain
    if [[ "$1" == 1 ]]; then debug=1; shift; fi
    # Convert args to arrays, handling both space- and newline-separated lists.
    local -a desired=("$1")
    local -a installed=("$2")
    #read -ra desired < <(echo "$1" | tr '\n' ' ')
    #read -ra installed < <(echo "$2" | tr '\n' ' ')
    # Sort desired and installed arrays.
    unset i; while read -r; do desired_s[i++]=$REPLY; done < <(
        printf "%s\n" "${desired[@]}" | sort
    )
    unset i; while read -r; do installed_s[i++]=$REPLY; done < <(
        printf "%s\n" "${installed[@]}" | sort
    )
    # Get the difference. comm is awesome.
    unset i; while read -r; do remain[i++]=$REPLY; done < <(
        comm -13 <(printf "%s\n" "${installed_s[@]}") <(printf "%s\n" "${desired_s[@]}")
    )
    [[ "$debug" ]] && for v in desired desired_s installed installed_s remain; do
        echo "$v ($(eval echo "\${#$v[*]}")) $(eval echo "\${$v[*]}")"
    done
    echo "${remain[@]}"
}

# Offer the user a chance to skip something.
function skip () {
    local REPLY=noskip
    read -t 5 -n 1 -s -p "To skip, press X within 5 seconds. "
    if [[ "$REPLY" =~ ^[Xx]$ ]]; then
        echo "Skipping!"
        return 0
    else
        echo "Continuing..."
        return 1
    fi
}

# Initialize.
function init_do() {
    e_header "Sourcing $2"
    source "$2"
}

# Copy files.
function copy_header() {
    if "${print_copy_header}"; then
        e_header "Copying files into home directory";
        print_copy_header=false
    fi
}

function copy_test() {
    if [[ -e "$2" && ! "$(cmp "$1" "$2" 2> /dev/null)" ]]; then
        echo "same file"
    elif [[ "$1" -ot "$2" ]]; then
        echo "destination file newer"
    fi
}

function copy_do() {
    dest_dir="$(pathname "$1")"
    [[ -e "$dest_dir" ]] || e_arrow "Creating $dest_dir." && mkdir -p "$dest_dir"
    e_success "Copying $2 to $1."
    cp "$2" "$1"
}

# Copy skeleton files.
function skel_header() {
    if "${print_skel_header}"; then
        e_header "Copying skeleton files into home directory";
        print_skel_header=false
    fi
}

function skel_test() {
    [[ -e "$2" ]] && echo "$2 already exists"
}

function skel_do() {
    dest_dir="$(pathname "$1")"
    [[ -e $dest_dir ]] || e_arrow "Creating $dest_dir." && mkdir -p "$dest_dir"
    e_success "Copying skeleton file $2 to $1."
    cp "$2" "$1"
}

# Link files.
function link_header() {
    if "${print_link_header}"; then
        e_header "Linking files into home directory";
        print_link_header=false
    fi
}

function link_test() {
    [[ "$1" -ef "$2" ]] && echo "same file"
}

function check_exists () {
    if "${DOTFILES_NOCLOBBER}"; then
        local dest_dir="$(pathname "$1")"
        local src_file=${2#$HOME/}
        local dest_file=$1

        for rcname in "${DOTFILES_NOCLOBBER_RCS[@]}"; do
            local rc="$dest_dir/.$rcname"
            if [[ ${1#$dest_dir/} =~ \.$rcname ]] && [[ $(cmp --silent "$src_file" "$rc") -eq 0 ]]
            then
                return 0
            fi
        done
    fi

    return 1
}

function link_do() {
    local dest_dir="$(pathname "$1")"
    #local src_file=${2#$HOME/}
    local src_file="$2"
    local dest_file=$1

    [[ -e $dest_dir ]] || e_arrow "Creating $dest_dir." && mkdir -p "$dest_dir"

    if check_exists "$1" "$2"; then
        dest_file="${dest_file}.custom"
        e_arrow "Not clobbering ${dest_file}; ${src_file} will be appended with '.custom'"
    fi

    ln -sf "$src_file" "$dest_file"

    e_success "Linking $src_file to $dest_file."
}

md5cmp () {
    local left right leftsumout rightsumout
    left="$1"
    right="$2"
    leftsumout="$(md5sum "$left")"
    rightsumout="$(md5sum "$right")"
    [[ "${leftsumout%% *}" == "${rightsumout%% *}" ]]
}

dirdiff () {
    local srcdir destdir srcfile destfile srcstem detailed
    local -A changed
    srcdir="$(readlink -e "$1")"
    destdir="$(readlink -e "$2")"

    if [[ -z "$srcdir" ]]; then
        echo "Could not find source directory '$1'" 1>&2
        return 1
    elif [[ -z "$destdir" ]]; then
        echo "Could not find destination directory '$2'" 1>&2
        return 1
    fi

    while read -r srcfile; do
        srcstem="${srcfile#$srcdir/}"
        destfile="${destdir}/${srcstem}"
        if ! [[ -r "$destfile" ]] || ! md5cmp "$srcfile" "$destfile"; then
            changed["$srcfile"]="$destfile"
        fi
    done < <(find "$srcdir" -xtype f)

    for key in "${!changed[@]}"; do
        echo "$key" "${changed["$key"]}"
    done
}

# Copy, link, init, etc.
function do_stuff() {
    local optype srcdir_relpath srcdir_fullpath dest filepath files fullpath relpath skip

    srcdir_relpath="${DOTFILES_ROOT}/${1}"
    if ! [[ -d "$srcdir_relpath" ]]; then
        echo "No such directory: $srcdir_relpath" 1>&2
        exit 1
    fi

    optype="${srcdir_relpath##*/}"
    if [[ -z "$optype" ]]; then
        echo "No optype specified" 1>&2
        exit 1
    fi

    # Run _header function only if declared.
    local header_func="${optype}_header"
    type -a "$header_func" &>/dev/null && "$header_func"

    # Iterate over files.
    while read -r srcfile destfile; do
        base=$(basename "$file")

        # If 'relpath' is not empty, filepath = relpath + base.
        # Otherwise filepath = base. (e.g., the filepath of
        # source/madeupdir/fakedir/dummy is madeupdir/fakedir/dummy)
        if [[ "$relpath" ]]; then
            filepath="$relpath/$base"
        else
            filepath="$base"
        fi

        # fullpath = full path to file relative to .dotfiles
        fullpath="$1/$base"
        dest="$HOME/$filepath"

        # if '$file' is a directory, create it in the
        # $HOME directory unless it already exists
        if [[ -d "$file" ]]; then
                # recurse on the directory so that
                # all files in subfolders get processed
                do_stuff "$fullpath" "$2"
                # skip to next iteration
                continue
        fi

        # Run _test function only if declared.
        local _test="_test"
        basedir_test="$basedir$_test"
        if [[ $(declare -f "$basedir_test") ]]; then
            # If _test function returns a string, skip file and print that message.
            skip="$("$basedir_test" "$file" "$dest")"
            if [[ "$skip" ]]; then
                e_error "Skipping $file, $skip."
                continue
            fi

            # Destination file already exists in ~/. Back it up!
            if [[ -e "$dest" ]]; then
                e_arrow "Backing up $dest."
                # Set backup flag, so a nice message can be shown at the end.
                backup=1
                # Create backup dir if it doesn't already exist.
                [[ -e "$backup_dir" ]] || mkdir -p "$backup_dir"
                # Backup file / link / whatever.
                #mv "$dest" "$backup_dir"
                cp "$dest" "$backup_dir"
            fi

        fi
        # Do stuff.
        local _do="_do"
        basedir_do="$basedir$_do"
        # This will invoke, e.g., link_do "/home/user/.bashrc" "/home/user/.dotfiles/link/.bashrc"
        "$basedir_do" "$dest" "$file"
    done < <()
}

# Iterate through directories in .dotfiles/opt,
# prompting user whether or not to process them.
function process_opt_dirs() {
    local dir_type
    local opt_dirs=($DOTFILES_ROOT/opt/*)
    local -a subdirs=(
        init
        copy
        skel
        link
    )

    if (( ${#opt_dirs[@]} == 0 )); then return; fi
    e_header "Processing optional directories"

    # Iterate over files.
    for dir in "${opt_dirs[@]}"; do
        opt_dir_base=$(basename "$dir")
        read -N 1 -t 15 -p "Process $opt_dir_base? [y/N] " process_dir; echo

        if [[ "$process_dir" =~ [Yy] ]]; then
            print_copy_header=true
            print_skel_header=true
            print_link_header=true

            for subdir in "${subdirs[@]}"; do
                    if [[ -d "$DOTFILES_ROOT/opt/$opt_dir_base/$subdir" ]]; then
                        do_stuff "$subdir" "opt/$opt_dir_base"
                    fi
            done
        fi
    done
}

function init_dotfiles() {
    local flags="-"
    DOTFILES_SKIP_INIT=true
    # Add command-line flag for skipping initialization
    flags="${flags}s"
    if [[ ! -d $DOTFILES_ROOT ]]; then
        DOTFILES_NEW_INSTALL=true
        # Add command-line flag for new install
        flags="${flags}n"
        # ~/.dotfiles doesn't exist? Clone it!
        e_header "Downloading dotfiles"
        git clone --recursive "$DOTFILES_REPO" "$DOTFILES_ROOT"
        cd "$DOTFILES_ROOT"
    else
        # Make sure we have the latest files.
        e_header "Updating dotfiles"
        cd "$DOTFILES_ROOT"
        git pull
        git submodule update --init --recursive --quiet
    fi

    "${DOTFILES_NOCLOBBER}" || flags="${flags}c"
    if ! "${print_link_header}" ||  ! "${print_copy_header}"; then
        flags="${flags}q"
    fi

    "${print_help}" && flags="${flags}h"

    e_header "Executing updated ${SCRIPT_BASENAME} script"
    exec "${SCRIPT_PATH}" "${flags}"
}

function intro() {
    echo 'Dotfiles - "Cowboy" Ben Alman - http://benalman.com/'

    if [[ "$1" == "-h" || "$1" == "--help" ]]; then cat <<HELP
Usage: $(basename "$0")

See the README for documentation.
https://github.com/cowboy/dotfiles

Copyright (c) 2012 "Cowboy" Ben Alman
Licensed under the MIT license.
http://benalman.com/about/license/
HELP
    exit; fi
}

# Enough with the functions, let's do stuff.

# Grab command-line options
while getopts ":nscqh" opt
do
    case $opt in
        n)
            DOTFILES_NEW_INSTALL=true
            ;;
        s)
            DOTFILES_SKIP_INIT=true
            ;;
        c)
            DOTFILES_NOCLOBBER=false
            ;;
        q)
            DOTFILES_VERBOSE=false
            ;;
        h)
            print_help=false
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            exit 1
            ;;
    esac
done

# Flags for whether to print link/copy/etc. optypes
print_copy_header=true
print_skel_header=true
print_link_header=true

for optype in copy skel link; do
        declare "print_${optype}_header=$DOTFILES_VERBOSE"
done

# Initial stuff; do only if we haven't updated to the newest version
if ! "$DOTFILES_SKIP_INIT"; then
    intro "${print_help}"

    e_header "Performing initial configuration"
    # Ensure that we can actually, like, compile anything.
    if ! command -v gcc >/dev/null 2>&1 && [[ "$OSTYPE" =~ ^darwin ]]; then
        e_error "XCode or the Command Line Tools for XCode must be installed first."
        exit 1
    fi
    e_header
    # If Git is not installed, install it (Ubuntu only, since Git comes standard with recent XCode or
    # CLT)
    if ! command -v git >/dev/null 2>&1; then
        e_error "Git should be installed. It isn't. Aborting."
        exit 1
    fi

    # Update existing sudo time stamp if set, otherwise do nothing.
    while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &

    # Initialize.
    e_header "Pulling in updated dotfiles repo"
    init_dotfiles
else
    e_header "Skipping initialization"
fi

# Source some utilities & helpers.
source "$DOTFILES_ROOT"/source/10_misc.sh

"${DOTFILES_NOCLOBBER}" && e_header "Preserving some existing configurations"

# Add binaries into the path
PATH=$DOTFILES_ROOT/bin:$PATH
export PATH

# Tweak file globbing.
shopt -s dotglob
shopt -s nullglob

# Create caches directory, if it doesn't already exist.
mkdir -p "$DOTFILES_ROOT/caches"

# If backups are needed, this is where they'll go.
backup_dir="$DOTFILES_ROOT/backup/$(date "+%Y_%m_%d-%H_%M_%S")/"
backup=

# Execute code for each file in these subdirectories.
do_stuff "init"
do_stuff "copy"
do_stuff "skel"
do_stuff "link"
process_opt_dirs

# Alert if backups were made.
if [[ "$backup" ]]; then
    echo -e "\nBackups were moved to ~/${backup_dir#${HOME}/}"
fi

# Lest I forget to do a few additional things...
if "${DOTFILES_NEW_INSTALL}" && [[ -f "conf/firsttime_reminder.sh" ]]; then
    e_header "This is a new installation"
    e_header "First-Time Reminders"
    source "conf/firsttime_reminder.sh"
fi

# All done!
e_header "All done!"
