#!/usr/bin/env bash

# Copyright (c) 2012 "Cowboy" Ben Alman
# Licensed under the MIT license.
# http://benalman.com/about/license/

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_vars () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Don't allow unset variables or uncaught errors
    set -o nounset
    #set -o errexit

    # Tweak file globbing.
    shopt -s dotglob
    shopt -s nullglob

    SCRIPT_PATH="${BASH_SOURCE[0]}"
    SCRIPT_BASENAME="${SCRIPT_PATH##*/}"
    SCRIPT_DIRNAME="${SCRIPT_PATH%/*}"

    # Globals
    : "${DOTFILES_DESTDIR:=$HOME}"
    : "${DOTFILES_ROOT:=$(readlink -e "${SCRIPT_DIRNAME}/../.dotfiles")}"
    : "${DOTFILES_REPO:=git://github.com/BaxterStockman/dotfiles.git}"
    : "${DOTFILES_NEW_INSTALL:=false}"
    : "${DOTFILES_SKIP_INIT:=false}"
    : "${DOTFILES_NOCLOBBER:=true}"
    : "${DOTFILES_VERBOSE:=true}"
    : "${DOTFILES_CACHE_PATH:=${DOTFILES_ROOT}/caches}"
    : "${DOTFILES_BACKUP_PATH:=${DOTFILES_ROOT}/backup/$(date "+%Y_%m_%d-%H_%M_%S")}"
    declare -gi __DOTFILES_BACKUP=0
    declare -gi __DOTFILES_FAILED=0

    # RC files to not clobber when linking
    declare -ga DOTFILES_NOCLOBBER_RCS=(
        bashrc
        bash_login
        bash_logout
        bash_profile
        muttrc
        subversion
        perlbrew
        ssh
    )
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Logging stuff
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
e_header ()   { echo -e "\n\033[1m$*\033[0m"; }
e_success ()  { echo -e " \033[1;32m✔\033[0m  $*"; }
e_error ()    { echo -e " \033[1;31m✖\033[0m  $*" 1>&2; }
e_arrow ()    { echo -e " \033[1;33m➜\033[0m  $*"; }

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
__make_pretty () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Reset IFS, i.e. ensure that it's ' '
    local IFS
    # Split on whitespace
    local -a maybe_util=($1)
    # Extract the first element
    local util="${maybe_util[0]}"

    if [[ -z $util  ]]; then
        echo "Please provide an executable name or path to wrap" 1>&2
        return 1
    fi

    cat <<META
${util}_pretty () {
    local ${util}_output="\$(${util} "\$@")";
    local -i exit_code=\$?;
    local line

    if [[ \$exit_code == 0 ]]; then
        while read -r ${util}_output_line; do
            e_arrow "\$${util}_output_line";
        done <<<\$${util}_output;
        return 0;
    else
        while read -r ${util}_output_line; do
            e_error "\$${util}_output_line";
        done <<<\$${util}_output;
        return 1;
    fi;
};
META
}

eval "$(__make_pretty 'mkdir')"
eval "$(__make_pretty 'cp')"
eval "$(__make_pretty 'ln')"

declare -f mkdir_pretty
declare -f ln_pretty

unset -f __make_pretty

# Given a list of desired items and installed items, return a list
# of uninstalled items. Arrays in bash are insane (not in a good way).
to_install () {
    local debug desired installed i desired_s installed_s remain
    if [[ "$1" == 1 ]]; then debug=1; shift; fi
    # Convert args to arrays, handling both space- and newline-separated lists.
    local -a desired=("$1")
    local -a installed=("$2")
    #read -ra desired < <(echo "$1" | tr '\n' ' ')
    #read -ra installed < <(echo "$2" | tr '\n' ' ')
    # Sort desired and installed arrays.
    unset i; while read -r; do desired_s[i++]=$REPLY; done < <(
        printf "%s\n" "${desired[@]}" | sort
    )
    unset i; while read -r; do installed_s[i++]=$REPLY; done < <(
        printf "%s\n" "${installed[@]}" | sort
    )
    # Get the difference. comm is awesome.
    unset i; while read -r; do remain[i++]=$REPLY; done < <(
        comm -13 <(printf "%s\n" "${installed_s[@]}") <(printf "%s\n" "${desired_s[@]}")
    )
    [[ "$debug" ]] && for v in desired desired_s installed installed_s remain; do
        echo "$v ($(eval echo "\${#$v[*]}")) $(eval echo "\${$v[*]}")"
    done
    echo "${remain[@]}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skip () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Offer the user a chance to skip something.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local REPLY=noskip
    read -t 5 -n 1 -s -p "To skip, press X within 5 seconds. "
    if [[ "$REPLY" =~ ^[Xx]$ ]]; then
        echo "Skipping!"
        return 0
    else
        echo "Continuing..."
        return 1
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_do() {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Initialize
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    e_header "Sourcing ${srcfile}"
    source "$srcfile"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy_header () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    e_header "Copying files into ${DOTFILES_DESTDIR}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy_test () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Ensures that files in the destination aren't overwritten if either
#   - The destination file is exactly the same as the source file; or
#   - The destination file is newer than the source file.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$1"

    if [[ -e "${destfile}" && ! "$(cmp "${srcfile}" "${destfile}" 2> /dev/null)" ]]; then
        echo "same file"
        return 1
    elif [[ "$1" -ot "$2" ]]; then
        echo "destination file newer"
        return 1
    fi

    return 0
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy_do () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Attempts to copy a file, printing pretty output
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"
    local destdir="${destfile%/*}"

    if ! mkdir_pretty -p "$destdir"; then
        e_error "Can't copy ${srcfile} to ${destfile}"
        return 1
    fi

    if ! cp "$srcfile" "$destfile"; then
        e_error "Failed to copy ${srcfile} to ${destfile}"
        return 1
    else
        e_success "Copied ${srcfile} to ${destfile}"
        return 0
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skel_header () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    e_header "Copying skeleton files into ${DOTFILES_DESTDIR}";
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skel_test () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# More restrictive than copy_test: if the destination file exists at all, don't
# overwrite it.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"

    if [[ -e "$destfile" ]]; then
        echo "${destfile} already exists"
        return 1
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skel_do () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Just another name for copy_do
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    copy_do "$@"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
link_header () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    e_header "Linking files into ${DOTFILES_DESTDIR}";
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
link_test () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"
    if [[ "${srcfile}" -ef "${destfile}" ]]; then
        echo "${destfile} already links to ${srcfile}"
        return 0
    fi

    return 1
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_exists () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if "${DOTFILES_NOCLOBBER}"; then
        local dest_dir="$(pathname "$1")"
        local srcfile=${2#$HOME/}
        local destfile=$1

        for rcname in "${DOTFILES_NOCLOBBER_RCS[@]}"; do
            local rc="$dest_dir/.$rcname"
            if [[ ${1#$dest_dir/} =~ \.$rcname ]] && [[ $(md5cmp "$src_file" "$rc") -eq 0 ]]; then
                return 0
            fi
        done
    fi

    return 1
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
link_do () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile=$2

    local destdir="${destfile%/*}"

    if ! mkdir_pretty -p "$destdir"; then
        e_error "Can't link ${destfile} to ${srcfile}"
        return 1
    fi

    if check_exists "$1" "$2"; then
        dest_file="${dest_file}.custom"
        e_arrow "Not clobbering ${dest_file}; ${src_file} will be appended with '.custom'"
    fi

    ln_pretty -sf "$srcfile" "$destfile"
    e_success "Linking ${srcfile} to ${destfile}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
md5cmp () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Minimize dependencies: cmp is in diffutils, md5sum is in coreutils.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local left right leftsumout rightsumout

    left="$1"
    right="$2"

    leftsumout="$(md5sum "$left")"
    rightsumout="$(md5sum "$right")"

    [[ "${leftsumout%% *}" == "${rightsumout%% *}" ]]
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
do_stuff () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Copy, link, init, etc.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optype srcdir_relpath srcdir

    # Little trick: this makes both 'do_stuff "link"' and 'do_stuff "opt/link"'
    # work as expected.
    srcdir_relpath="$1"
    optype="${srcdir_relpath##*/}"
    if [[ -z "$optype" ]]; then
        echo "No optype specified" 1>&2
        return 1
    fi

    srcdir="${DOTFILES_ROOT}/${srcdir_relpath}"
    if ! [[ -d "$srcdir" ]]; then
        e_error "No such directory: $srcdir"
        return 1
    fi

    # Run _header function only if declared.
    local optype_header="${optype}_header"
    local optype_do="${optype}_do"
    declare -F "$optype_header" &>/dev/null && "$optype_header"

    # Run _test function only if declared.
    local test_func="${optype}_test"

    # Iterate over files.
    local skip_reason srcfile srcstem destfile backup_subpath
    local -i failed=0
    for srcfile in $(find "$srcdir" -xtype f); do
        srcstem="${srcfile#$srcdir/}"
        destfile="${DOTFILES_DESTDIR}/${srcstem}"

        if declare -f "$test_func" &>/dev/null; then
            # If _test function returns a string, skip file and print that
            # message.
            skip_reason="$("$test_func" "$srcfile" "$destfile")"
            if [[ -n "$skip_reason" ]]; then
                e_error "Skipping ${optype}/${srcstem}: ${skip_reason}."
                continue
            fi

            # Destination file already exists in ~/. Back it up!
            if [[ -e "$destfile" ]]; then
                e_arrow "Backing up ${destfile}."
                # Set backup flag, so a nice message can be shown at the end.
                ((__DOTFILES_BACKUP++))

                backup_subpath="${DOTFILES_BACKUP_PATH}/${destfile%/*}"
                # Create backup dir if it doesn't already exist.
                if ! [[ -e "$backup_subpath" ]]; then
                    mkdir -p "$backup_subpath"
                elif ! [[ -d "$backup_subpath" ]]; then
                    e_error "${backup_subpath} exists but is not a directory"
                    ((failed++))
                fi

                cp "$destfile" "$backup_subpath"
            fi
        fi

        # Do stuff.
        "$optype_do" "$srcfile" "$destfile"
    done

    [[ $failed -eq 0 ]]
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
do_opt_stuff () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Iterate through directories in .dotfiles/opt,
# prompting user whether or not to process them.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcdir_relpath="$1"

    if [[ -d "${DOTFILES_ROOT}/${srcdir_relpath}" ]]; then
        local do_process
        read -N 1 -t 15 -p "Process optional ${srcdir_relpath##*/} files? [y/N] " do_process
        echo

        if [[ "$do_process" =~ [Yy] ]]; then
            do_stuff "$srcdir_relpath"
        fi
    fi

    return 0
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_dotfiles() {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    $DOTFILES_SKIP_INIT && return 0

    # Skip this function after we exec the updated version of this script.
    export DOTFILES_SKIP_INIT=true

    if [[ ! -d $DOTFILES_ROOT ]]; then
        # If the root directory doesn't exist, treat this as a new
        # installation.
        export DOTFILES_NEW_INSTALL=true
        e_header "Downloading dotfiles"
        git clone --recursive "$DOTFILES_REPO" "$DOTFILES_ROOT"
    else
        # Make sure we have the latest files.
        e_header "Updating dotfiles"
        pushd "$DOTFILES_ROOT" >/dev/null
        git pull
        git submodule update --init --recursive --quiet || :
    fi

    e_header "Executing updated ${SCRIPT_BASENAME} script"
    exec "${SCRIPT_PATH}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
usage () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -i return_code=${1:-0}
        cat <<EOF
Usage: $SCRIPT_BASENAME [-n] [-c] [-h]

See the README for documentation. https://github.com/cowboy/dotfiles

Copyright (c) 2012 "Cowboy" Ben Alman Licensed under the MIT license.
http://benalman.com/about/license/
EOF
    return $return_code
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    init_vars

    # Grab command-line options
    while (( $# )); do
        read opt_name opt_value <<<"$@"
        case "${opt_name/-?(-)/}"/ in
            n|new-install)
                DOTFILES_NEW_INSTALL=true
                ;;
            s|skip-init)
                DOTFILES_SKIP_INIT=true
                ;;
            c|clobber)
                DOTFILES_NOCLOBBER=false
                ;;
            v|verbose)
                DOTFILES_VERBOSE=true
                ;;
            q|quiet)
                DOTFILES_VERBOSE=false
                ;;
            h|help)
                print_help=false
                ;;
            \?)
                echo "Invalid option: ${opt_name}" 1>&2
                exit 1
                ;;
        esac
    done

    # Initial stuff; do only if we haven't updated to the newest version
    if ! "$DOTFILES_SKIP_INIT"; then
        usage

        e_header "Performing initial configuration"

        # Ensure that we can actually, like, compile anything.
        if ! command -v gcc >/dev/null 2>&1 && [[ "$OSTYPE" =~ ^darwin ]]; then
            e_error "XCode or the Command Line Tools for XCode must be installed first."
            exit 1
        fi

        e_header

        # If Git is not installed, install it (Ubuntu only, since Git comes
        # standard with recent XCode or CLT)
        if ! type -a git >/dev/null 2>&1; then
            e_error "Git should be installed. It isn't. Aborting."
            exit 1
        fi

        # Update existing sudo time stamp if set, otherwise do nothing.
        while true; do
            sudo -n true
            sleep 60
            kill -0 "$$" || exit
        done 2>/dev/null &

        # Initialize.
        e_header "Pulling in updated dotfiles repo"
        init_dotfiles
    else
        e_header "Skipping initialization"
    fi

    "${DOTFILES_NOCLOBBER}" \
        && e_header "Preserving some existing configurations"

    # Add binaries into the path
    PATH="${DOTFILES_ROOT}/bin${PATH:+:}${PATH}"
    export PATH

    # Create caches directory, if it doesn't already exist.
    mkdir -p "$DOTFILES_CACHE_PATH"

    # Execute code for each file in these subdirectories.
    for optype in init copy skel link; do
        do_stuff "$optype"
        do_opt_stuff "$optype"
    done

    # Alert if backups were made.
    if [[ "$__DOTFILES_BACKUP" -gt 0 ]]; then
        printf "\n%s\n" "Backups were moved to ${DOTFILES_BACKUP_PATH}"
    fi

    # Lest I forget to do a few additional things...
    if "${DOTFILES_NEW_INSTALL}" && [[ -f "conf/firsttime_reminder.sh" ]]; then
        e_header "This is a new installation"
        e_header "First-Time Reminders"
        source "conf/firsttime_reminder.sh"
    fi

    # All done!
    e_header "All done!"
    return 0
}

# Enough with the functions, let's do stuff.
main "$@"
exit $?
