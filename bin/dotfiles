#!/usr/bin/env bash

# Copyright (c) 2012 "Cowboy" Ben Alman
# Licensed under the MIT license.
# http://benalman.com/about/license/

init () {
    # Don't allow unset variables or uncaught errors
    set -o nounset
    set -o errexit

    # Tweak file globbing.
    shopt -s dotglob
    shopt -s nullglob

    SCRIPT_PATH="${BASH_SOURCE[0]}"
    SCRIPT_BASENAME="${SCRIPT_PATH##*/}"
    SCRIPT_DIRNAME="${SCRIPT_PATH%/*}"

    # Globals
    : "${DOTFILES_HOME:=$HOME}"
    : "${DOTFILES_ROOT:=$(readlink -e "${SCRIPT_DIRNAME}/../.dotfiles")}"
    : "${DOTFILES_REPO:=git://github.com/BaxterStockman/dotfiles.git}"
    : "${DOTFILES_NEW_INSTALL:=false}"
    : "${DOTFILES_SKIP_INIT:=false}"
    : "${DOTFILES_NOCLOBBER:=true}"
    : "${DOTFILES_VERBOSE:=true}"
    : "${DOTFILES_CACHE_PATH:=${DOTFILES_ROOT}/caches}"
    : "${DOTFILES_BACKUP_PATH:=${DOTFILES_ROOT}/backup/$(date "+%Y_%m_%d-%H_%M_%S")}"

    # Flags for whether to print link/copy/etc. optypes
    print_copy_header=true
    print_skel_header=true
    print_link_header=true

    # Flag for whether to print help doc
    print_help=false

    # RC files to not clobber when linking
    declare -a DOTFILES_NOCLOBBER_RCS=(
        bashrc
        bash_login
        bash_logout
        bash_profile
        muttrc
        subversion
        perlbrew
        ssh
    )
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Logging stuff.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
e_header ()   { echo -e "\n\033[1m$*\033[0m"; }
e_success ()  { echo -e " \033[1;32m✔\033[0m  $*"; }
e_error ()    { echo -e " \033[1;31m✖\033[0m  $*"; }
e_arrow ()    { echo -e " \033[1;33m➜\033[0m  $*"; }

# Given a list of desired items and installed items, return a list
# of uninstalled items. Arrays in bash are insane (not in a good way).
to_install () {
    local debug desired installed i desired_s installed_s remain
    if [[ "$1" == 1 ]]; then debug=1; shift; fi
    # Convert args to arrays, handling both space- and newline-separated lists.
    local -a desired=("$1")
    local -a installed=("$2")
    #read -ra desired < <(echo "$1" | tr '\n' ' ')
    #read -ra installed < <(echo "$2" | tr '\n' ' ')
    # Sort desired and installed arrays.
    unset i; while read -r; do desired_s[i++]=$REPLY; done < <(
        printf "%s\n" "${desired[@]}" | sort
    )
    unset i; while read -r; do installed_s[i++]=$REPLY; done < <(
        printf "%s\n" "${installed[@]}" | sort
    )
    # Get the difference. comm is awesome.
    unset i; while read -r; do remain[i++]=$REPLY; done < <(
        comm -13 <(printf "%s\n" "${installed_s[@]}") <(printf "%s\n" "${desired_s[@]}")
    )
    [[ "$debug" ]] && for v in desired desired_s installed installed_s remain; do
        echo "$v ($(eval echo "\${#$v[*]}")) $(eval echo "\${$v[*]}")"
    done
    echo "${remain[@]}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Offer the user a chance to skip something.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function skip () {
    local REPLY=noskip
    read -t 5 -n 1 -s -p "To skip, press X within 5 seconds. "
    if [[ "$REPLY" =~ ^[Xx]$ ]]; then
        echo "Skipping!"
        return 0
    else
        echo "Continuing..."
        return 1
    fi
}

# Initialize.
function init_do() {
    e_header "Sourcing $1"
    source "$1"
}

# Copy files.
function copy_header() {
    e_header "Copying files into ${DOTFILES_HOME}";
}

function copy_test() {
    if [[ -e "$2" && ! "$(cmp "$1" "$2" 2> /dev/null)" ]]; then
        echo "same file"
        return 1
    elif [[ "$1" -ot "$2" ]]; then
        echo "destination file newer"
        return 1
    fi

    return 0
}

mkdir_pretty () {
    local mkdir_output="$(mkdir "$@")"
    local -i exit_code=$?

    if [[ $exit_code == 0 ]]; then
        while read -r mkdir_output_line; do
            e_arrow "$mkdir_output_line"
        done
        return 0
    else
        while read -r mkdir_output_line; do
            e_error "$mkdir_output_line"
        done
        return 1
    fi
}

cp_pretty () {
    local cp_output
    cp_output="$(cp "$@")"
    local -i exit_code=$?

    if [[ $exit_code == 0 ]]; then
        while read -r cp_output_line; do
            e_arrow "$cp_output_line"
        done
        return 0
    else
        while read -r cp_output_line; do
            e_error "$cp_output_line"
        done
        return 1
    fi
}

function copy_do() {
    local srcfile="$1"
    local destfile="$2"
    local destdir="${destfile%/*}"

    if ! mkdir_pretty -p "$destdir"; then
        e_error "Can't copy ${srcfile} to ${destfile}"
        return 1
    fi

    if ! cp "$srcfile" "$desfile"; then
        e_error "Failed to copy ${srcfile} to ${destfile}"
        return 1
    else
        e_success "Copied ${srcfile} to ${destfile}"
        return 0
    fi
}

# Copy skeleton files.
function skel_header () {
    e_header "Copying skeleton files into ${DOTFILES_HOME}";
}

function skel_test() {
    local srcfile="$1"
    local destfile="$2"

    if [[ -e "$destfile" ]]; then
        echo "${destfile} already exists"
        return 1
    fi
}

function skel_do() {
    copy_do "$@"
}

# Link files.
function link_header() {
    e_header "Linking files into ${DOTFILES_HOME}";
}

function link_test() {
    [[ "$1" -ef "$2" ]] && echo "same file"
}

function check_exists () {
    if "${DOTFILES_NOCLOBBER}"; then
        local dest_dir="$(pathname "$1")"
        local src_file=${2#$HOME/}
        local dest_file=$1

        for rcname in "${DOTFILES_NOCLOBBER_RCS[@]}"; do
            local rc="$dest_dir/.$rcname"
            if [[ ${1#$dest_dir/} =~ \.$rcname ]] && [[ $(cmp --silent "$src_file" "$rc") -eq 0 ]]
            then
                return 0
            fi
        done
    fi

    return 1
}

function link_do() {
    local dest_dir="$(pathname "$1")"
    #local src_file=${2#$HOME/}
    local src_file="$2"
    local dest_file=$1

    [[ -e $dest_dir ]] || e_arrow "Creating $dest_dir." && mkdir -p "$dest_dir"

    if check_exists "$1" "$2"; then
        dest_file="${dest_file}.custom"
        e_arrow "Not clobbering ${dest_file}; ${src_file} will be appended with '.custom'"
    fi

    ln -sf "$src_file" "$dest_file"

    e_success "Linking $src_file to $dest_file."
}

md5cmp () {
    local left right leftsumout rightsumout
    left="$1"
    right="$2"
    leftsumout="$(md5sum "$left")"
    rightsumout="$(md5sum "$right")"
    [[ "${leftsumout%% *}" == "${rightsumout%% *}" ]]
}

dirdiff () {
    local srcdir destdir srcfile destfile srcstem detailed
    local -A changed
    srcdir="$(readlink -e "$1")"
    destdir="$(readlink -e "$2")"

    if [[ -z "$srcdir" ]]; then
        echo "Could not find source directory '$1'" 1>&2
        return 1
    elif [[ -z "$destdir" ]]; then
        echo "Could not find destination directory '$2'" 1>&2
        return 1
    fi

    while read -r srcfile; do
        srcstem="${srcfile#$srcdir/}"
        destfile="${destdir}/${srcstem}"
        if ! [[ -r "$destfile" ]] || ! md5cmp "$srcfile" "$destfile"; then
            changed["$srcfile"]="$destfile"
        fi
    done < <(find "$srcdir" -xtype f)

    for key in "${!changed[@]}"; do
        echo "$key" "${changed["$key"]}"
    done
}

# Copy, link, init, etc.
function do_stuff() {
    local optype srcdir dest filepath files fullpath relpath skip

    optype="$1"
    srcdir="${DOTFILES_ROOT}/${optype}"
    if ! [[ -d "$srcdir" ]]; then
        echo "No such directory: $srcdir" 1>&2
        return 1
    fi

    optype="${srcdir##*/}"
    if [[ -z "$optype" ]]; then
        echo "No optype specified" 1>&2
        return 1
    fi

    # Run _header function only if declared.
    local optype_header="${optype}_header"
    local optype_do="${optype}_do"
    declare -F "$optype_header" &>/dev/null && "$optype_header"

    # Iterate over files.
    while read -r srcfile destfile; do
        # Run _test function only if declared.
        local test_func="${optype}_test"

        if declare -f "$test_func" &>/dev/null; then
            # If _test function returns a string, skip file and print that
            # message.
            skip="$("$test_func" "$srcfile" "$destfile")"
            if [[ -n "$skip" ]]; then
                e_error "Skipping ${srcfile#$srcdir}: ${skip}."
                continue
            fi

            # Destination file already exists in ~/. Back it up!
            if [[ -e "$destfile" ]]; then
                e_arrow "Backing up ${destfile}."
                # Set backup flag, so a nice message can be shown at the end.
                backup=1
                # Create backup dir if it doesn't already exist.
                [[ -e "$backup_dir" ]] || mkdir -p "$backup_dir"
                # Backup file / link / whatever.
                #mv "$dest" "$backup_dir"
                cp "$dest" "$backup_dir"
            fi

        fi
        # Do stuff.
        # This will invoke, e.g., link_do "/home/user/.bashrc" "/home/user/.dotfiles/link/.bashrc"
        "$optype_do" "$dest" "$file"
    done < <(dirdiff "$srcdir" "$destdir")
}

# Iterate through directories in .dotfiles/opt,
# prompting user whether or not to process them.
function process_opt_dirs() {
    local dir_type
    local opt_dirs=($DOTFILES_ROOT/opt/*)
    local -a subdirs=(
        init
        copy
        skel
        link
    )

    if (( ${#opt_dirs[@]} == 0 )); then return; fi
    e_header "Processing optional directories"

    # Iterate over files.
    for dir in "${opt_dirs[@]}"; do
        opt_dir_base=$(basename "$dir")
        read -N 1 -t 15 -p "Process $opt_dir_base? [y/N] " process_dir; echo

        if [[ "$process_dir" =~ [Yy] ]]; then
            print_copy_header=true
            print_skel_header=true
            print_link_header=true

            for subdir in "${subdirs[@]}"; do
                    if [[ -d "$DOTFILES_ROOT/opt/$opt_dir_base/$subdir" ]]; then
                        do_stuff "$subdir" "opt/$opt_dir_base"
                    fi
            done
        fi
    done
}

function init_dotfiles() {
    export DOTFILES_SKIP_INIT=true
    # Add command-line flag for skipping initialization
    flags="${flags}s"
    if [[ ! -d $DOTFILES_ROOT ]]; then
        DOTFILES_NEW_INSTALL=true
        # Add command-line flag for new install
        flags="${flags}n"
        # ~/.dotfiles doesn't exist? Clone it!
        e_header "Downloading dotfiles"
        git clone --recursive "$DOTFILES_REPO" "$DOTFILES_ROOT"
        cd "$DOTFILES_ROOT"
    else
        # Make sure we have the latest files.
        e_header "Updating dotfiles"
        cd "$DOTFILES_ROOT"
        git pull
        git submodule update --init --recursive --quiet
    fi

    "${DOTFILES_NOCLOBBER}" || flags="${flags}c"
    if ! "${print_link_header}" ||  ! "${print_copy_header}"; then
        flags="${flags}q"
    fi

    "${print_help}" && flags="${flags}h"

    e_header "Executing updated ${SCRIPT_BASENAME} script"
    exec "${SCRIPT_PATH}" "${flags}"
}

function intro() {
    echo 'Dotfiles - "Cowboy" Ben Alman - http://benalman.com/'

    if [[ "$1" == "-h" || "$1" == "--help" ]]; then cat <<HELP
Usage: $(basename "$0")

See the README for documentation.
https://github.com/cowboy/dotfiles

Copyright (c) 2012 "Cowboy" Ben Alman
Licensed under the MIT license.
http://benalman.com/about/license/
HELP
    exit; fi
}

main () {
    # Grab command-line options
    while (( $# )); do
        read opt_name opt_value <<<"$@"
        case "${opt_name/-?(-)/}"/ in
            n|new-install)
                DOTFILES_NEW_INSTALL=true
                ;;
            s|skip-init)
                DOTFILES_SKIP_INIT=true
                ;;
            C|no-clobber)
                DOTFILES_NOCLOBBER=false
                ;;
            v|verbose)
                DOTFILES_VERBOSE=true
                ;;
            q|quiet)
                DOTFILES_VERBOSE=false
                ;;
            h|help)
                print_help=false
                ;;
            \?)
                echo "Invalid option: ${opt_name}" 1>&2
                exit 1
                ;;
        esac
    done

    # Flags for whether to print link/copy/etc. optypes
    print_copy_header=true
    print_skel_header=true
    print_link_header=true

    for optype in copy skel link; do
            declare "print_${optype}_header=$DOTFILES_VERBOSE"
    done

    # Initial stuff; do only if we haven't updated to the newest version
    if ! "$DOTFILES_SKIP_INIT"; then
        intro "${print_help}"

        e_header "Performing initial configuration"

        # Ensure that we can actually, like, compile anything.
        if ! command -v gcc >/dev/null 2>&1 && [[ "$OSTYPE" =~ ^darwin ]]; then
            e_error "XCode or the Command Line Tools for XCode must be installed first."
            exit 1
        fi

        e_header

        # If Git is not installed, install it (Ubuntu only, since Git comes
        # standard with recent XCode or CLT)
        if ! type -a git >/dev/null 2>&1; then
            e_error "Git should be installed. It isn't. Aborting."
            exit 1
        fi

        # Update existing sudo time stamp if set, otherwise do nothing.
        while true; do
            sudo -n true
            sleep 60
            kill -0 "$$" || exit
        done 2>/dev/null &

        # Initialize.
        e_header "Pulling in updated dotfiles repo"
        init_dotfiles
    else
        e_header "Skipping initialization"
    fi

    "${DOTFILES_NOCLOBBER}" \
        && e_header "Preserving some existing configurations"

    # Add binaries into the path
    PATH="${DOTFILES_ROOT}/bin${PATH:+:}${PATH}"
    export PATH

    # Create caches directory, if it doesn't already exist.
    mkdir -p "$DOTFILES_CACHE_PATH"

    # Execute code for each file in these subdirectories.
    do_stuff "init"
    do_stuff "copy"
    do_stuff "skel"
    do_stuff "link"
    process_opt_dirs

    # Alert if backups were made.
    if [[ "$backup" ]]; then
        printf "\n%s\n" "Backups were moved to ${DOTFILES_BACKUP_PATH}"
    fi

    # Lest I forget to do a few additional things...
    if "${DOTFILES_NEW_INSTALL}" && [[ -f "conf/firsttime_reminder.sh" ]]; then
        e_header "This is a new installation"
        e_header "First-Time Reminders"
        source "conf/firsttime_reminder.sh"
    fi

    # All done!
    e_header "All done!"
    return 0
}

# Enough with the functions, let's do stuff.
exit main "$@"
