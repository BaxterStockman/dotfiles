#!/usr/bin/env bash

# Copyright (c) 2012 "Cowboy" Ben Alman
# Licensed under the MIT license.
# http://benalman.com/about/license/

# Globals
DOTFILES_ROOT="$HOME/.dotfiles"
DOTFILES_GIT=git://github.com/BaxterStockman/dotfiles.git
SCRIPT_NAME="dotfiles"
SCRIPT="$DOTFILES_ROOT/bin/$SCRIPT_NAME"

# Global flow control flags
new_dotfiles_install="0"
skip_init="0"
noclobber="1"

# Flags for whether to print link/copy/etc. operations
print_want_header="1"
print_cpan_header="1"
print_copy_header="1"
print_skel_header="1"
print_link_header="1"

# Flag for whether to print help doc
print_help="0"

# RC files to not clobber when linking
declare -a noclobber_rcs=(bashrc bash_login bash_logout bash_profile muttrc subversion perlbrew ssh)

# Set package manager stuff based on platform
if [[ "$(cat /etc/issue 2> /dev/null)" =~ Arch ]]; then
    PKG_INSTALL="packer -S "
    PKG_CHECK_INSTALLED="pacman -Qqs "
    PKG_CHECK_AVAIL="packer -Sqs "
elif [[ "$OSTYPE" =~ ^darwin ]]; then
    PKG_INSTALL="brew install "
    PKG_CHECK_INSTALLED="brew list --versions "
    PKG_CHECK_AVAIL="brew search "
elif [[ "$(cat /etc/issue 2> /dev/null)" =~ Ubuntu ]];then
    PKG_INSTALL="sudo apt-get install "
    PKG_CHECK_INSTALLED="dpkg -s "
    PKG_CHECK_AVAIL="apt-cache search "
else
    PKG_INSTALL=""
fi

# Get cpanm binary paths
for bin in $(whereis cpanm); do
  case $bin in
    ${HOME}*cpanm)
      CPANM_LOCAL=$bin
      ;;
    *cpanm)
      CPANM_SYS="$bin --sudo"
      ;;
    *)
      ;;
  esac
done

# Logging stuff.
function e_header()   { echo -e "\n\033[1m$*\033[0m"; }
function e_success()  { echo -e " \033[1;32m✔\033[0m  $*"; }
function e_error()    { echo -e " \033[1;31m✖\033[0m  $*"; }
function e_arrow()    { echo -e " \033[1;33m➜\033[0m  $*"; }

# Given a list of desired items and installed items, return a list
# of uninstalled items. Arrays in bash are insane (not in a good way).
function to_install() {
  local debug desired installed i desired_s installed_s remain
  if [[ "$1" == 1 ]]; then debug=1; shift; fi
  # Convert args to arrays, handling both space- and newline-separated lists.
  read -ra desired < <(echo "$1" | tr '\n' ' ')
  read -ra installed < <(echo "$2" | tr '\n' ' ')
  # Sort desired and installed arrays.
  unset i; while read -r; do desired_s[i++]=$REPLY; done < <(
    printf "%s\n" "${desired[@]}" | sort
  )
  unset i; while read -r; do installed_s[i++]=$REPLY; done < <(
    printf "%s\n" "${installed[@]}" | sort
  )
  # Get the difference. comm is awesome.
  unset i; while read -r; do remain[i++]=$REPLY; done < <(
    comm -13 <(printf "%s\n" "${installed_s[@]}") <(printf "%s\n" "${desired_s[@]}")
  )
  [[ "$debug" ]] && for v in desired desired_s installed installed_s remain; do
    echo "$v ($(eval echo "\${#$v[*]}")) $(eval echo "\${$v[*]}")"
  done
  echo "${remain[@]}"
}

# Offer the user a chance to skip something.
function skip() {
  REPLY=noskip
  read -t 5 -n 1 -s -p "To skip, press X within 5 seconds. "
  if [[ "$REPLY" =~ ^[Xx]$ ]]; then
    echo "Skipping!"
  else
    echo "Continuing..."
    return 1
  fi
}

# Initialize.
function init_do() {
  e_header "Sourcing $2"
  source "$2"
}

# Copy files.
function want_header() {
  if [[ "$print_want_header" -eq "1" ]]; then
    e_header "Installing packages";
    print_want_header="0"
  fi
}

function want_test() {
    if [[ -z $PKG_INSTALL ]]; then
      echo "no package manager available"
    fi
}

# Initialize.
function want_do() {
  pkgs="$(tr '\n' ' ' < "$2")"
  to_install=""

  for pkg in $pkgs; do
      if ! exists "$pkg" && [[ -z "$("$PKG_CHECK_INSTALLED" "$pkg")" ]] && [[ -n "$("$PKG_CHECK_AVAIL" "$pkg")" ]]; then
      to_install="$to_install $pkg"
    fi
  done

  if [[ -n $to_install ]]; then
    e_header "Installing $to_install"
    "$PKG_INSTALL" "$to_install"
  fi
}

# Copy files.
function cpan_header() {
  if [[ "$print_cpan_header" -eq "1" ]]; then
    e_header "Installing CPAN modules";
    print_cpan_header="0"
  fi
}

function cpan_test() {
    if ! exists cpanm; then
      echo "cpanm CPAN module management utility not available"
    fi
}

# Initialize.
function cpan_do() {
  local CPANM

  # Install to system perl libs if the file we're processing is in the 'system' subdirectory
  if [[ "$2" =~ system/[^/]+$ ]]; then
    CPANM="$CPANM_SYS"
  elif [[ "$2" =~ local/[^/]+$ ]]; then
    CPANM="$CPANM_LOCAL"
  else
    return 1
  fi

  # Try to install package; if something breaks, ask for manual intervention
  for pkg in $(tr '\n' ' ' < "$2"); do
    if ! "$CPANM" "$pkg"; then
      "$CPANM" --interactive "$pkg"
    fi
  done
}

# Copy files.
function copy_header() {
  if [[ "$print_copy_header" -eq "1" ]]; then
    e_header "Copying files into home directory";
    print_copy_header="0"
  fi
}

function copy_test() {
  if [[ -e "$2" && ! "$(cmp "$1" "$2" 2> /dev/null)" ]]; then
    echo "same file"
  elif [[ "$1" -ot "$2" ]]; then
    echo "destination file newer"
  fi
}

function copy_do() {
  dest_dir="$(pathname "$1")"
  [[ -e "$dest_dir" ]] || e_arrow "Creating $dest_dir." && mkdir -p "$dest_dir"
  e_success "Copying $2 to $1."
  cp "$2" "$1"
}

# Copy skeleton files.
function skel_header() {
  if [[ "$print_skel_header" -eq "1" ]]; then
    e_header "Copying skeleton files into home directory";
    print_skel_header="0"
  fi
}

function skel_test() {
  [[ -e "$2" ]] && echo "$2 already exists"
}

function skel_do() {
  dest_dir="$(pathname "$1")"
  [[ -e $dest_dir ]] || e_arrow "Creating $dest_dir." && mkdir -p "$dest_dir"
  e_success "Copying skeleton file $2 to $1."
  cp "$2" "$1"
}

# Link files.
function link_header() {
  if [[ "$print_link_header" -eq "1" ]]; then
    e_header "Linking files into home directory";
    print_link_header="0"
  fi
}

function link_test() {
  [[ "$1" -ef "$2" ]] && echo "same file"
}

function check_exists () {
  if [[ $noclobber -eq 1 ]]
  then
    local dest_dir="$(pathname "$1")"
    local src_file=${2#$HOME/}
    local dest_file=$1

    for rcname in "${noclobber_rcs[@]}"; do
      local rc="$dest_dir/.$rcname"
      if [[ ${1#$dest_dir/} =~ \.$rcname ]] && [[ $(cmp --silent "$src_file" "$rc") -eq 0 ]]
      then
        return 0
      fi
    done
  fi

  return 1
}

function link_do() {
  local dest_dir="$(pathname "$1")"
  local src_file=${2#$HOME/}
  local dest_file=$1

  [[ -e $dest_dir ]] || e_arrow "Creating $dest_dir." && mkdir -p "$dest_dir"

  if check_exists "$1" "$2"
  then
    dest_file="${1}.custom"
    e_arrow "Not clobbering $1; $2 will be appended with '.custom'"
  fi

  ln -sf "$src_file" "$dest_file"

  e_success "Linking $src_file to $dest_file."
}


# Copy, link, init, etc.
function do_stuff() {
  local base basedir dest filepath files fullpath relpath skip

  # '$1' holds the name of a subdirectory of .dotfiles or .dotfiles/opt/*/
  # '$2' holds the option 'opt/*/'
  if [[ "$2" ]]; then
    files=($DOTFILES_ROOT/$2/$1/*)
  else
    files=($DOTFILES_ROOT/$1/*)
  fi

  # No files? abort.
  if (( ${#files[@]} == 0 )); then return; fi

  basedir=$(basedir "$1")

  # relpath() returns the pathname relative
  # to an immediate subdirectory of .dotfiles
  # (e.g. the relpath of source/madeupdir/fakedir
  # would be madeupdir/fakedir)
  relpath=$(relpath "$1")

  # Run _header function only if declared.
  local _header="_header"
  [[ $(declare -f "$basedir$_header") ]] && "$basedir$_header"

  # Iterate over files.
  for file in "${files[@]}"; do
    base=$(basename "$file")

    # If 'relpath' is not empty, filepath = relpath + base.
    # Otherwise filepath = base. (e.g., the filepath of
    # source/madeupdir/fakedir/dummy is madeupdir/fakedir/dummy)
    if [[ "$relpath" ]]; then
      filepath="$relpath/$base"
    else
      filepath="$base"
    fi

    # fullpath = full path to file relative to .dotfiles
    fullpath="$1/$base"
    dest="$HOME/$filepath"

    # if '$file' is a directory, create it in the
    # $HOME directory unless it already exists
    if [[ -d "$file" ]]; then
        # recurse on the directory so that
        # all files in subfolders get processed
        do_stuff "$fullpath" "$2"
        # skip to next iteration
        continue
    fi

    # Run _test function only if declared.
    local _test="_test"
    basedir_test="$basedir$_test"
    if [[ $(declare -f "$basedir_test") ]]; then
      # If _test function returns a string, skip file and print that message.
      skip="$("$basedir_test" "$file" "$dest")"
      if [[ "$skip" ]]; then
        e_error "Skipping $file, $skip."
        continue
      fi

      # Destination file already exists in ~/. Back it up!
      if [[ -e "$dest" ]]; then
        e_arrow "Backing up $dest."
        # Set backup flag, so a nice message can be shown at the end.
        backup=1
        # Create backup dir if it doesn't already exist.
        [[ -e "$backup_dir" ]] || mkdir -p "$backup_dir"
        # Backup file / link / whatever.
        #mv "$dest" "$backup_dir"
        cp "$dest" "$backup_dir"
      fi

    fi
    # Do stuff.
    local _do="_do"
    basedir_do="$basedir$_do"
    # This will invoke, e.g., link_do "/home/user/.bashrc" "/home/user/.dotfiles/link/.bashrc"
    "$basedir_do" "$dest" "$file"
  done
}

# Iterate through directories in .dotfiles/opt,
# prompting user whether or not to process them.
function process_opt_dirs() {
  local dir_type
  local opt_dirs=($DOTFILES_ROOT/opt/*)
  local subdirs=(
    init
    want
    cpan
    copy
    skel
    link
  )

  if (( ${#opt_dirs[@]} == 0 )); then return; fi
  e_header "Processing optional directories"

  # Iterate over files.
  for dir in "${opt_dirs[@]}"; do
    opt_dir_base=$(basename "$dir")
    read -N 1 -t 15 -p "Process $opt_dir_base? [y/N] " process_dir; echo

    if [[ "$process_dir" =~ [Yy] ]]; then
      print_want_header="1"
      print_cpan_header="1"
      print_copy_header="1"
      print_skel_header="1"
      print_link_header="1"

      for subdir in "${subdirs[@]}"; do
          if [[ -d "$DOTFILES_ROOT/opt/$opt_dir_base/$subdir" ]]; then
            do_stuff "$subdir" "opt/$opt_dir_base"
          fi
      done
    fi
  done
}

function init_dotfiles() {
  local flags="-"
  skip_init=1
  # Add command-line flag for skipping initialization
  flags="${flags}s"
  if [[ ! -d $DOTFILES_ROOT ]]; then
    new_dotfiles_install=1
    # Add command-line flag for new install
    flags="${flags}n"
    # ~/.dotfiles doesn't exist? Clone it!
    e_header "Downloading dotfiles"
    git clone --recursive "$DOTFILES_GIT" "$DOTFILES_ROOT"
    cd "$DOTFILES_ROOT"
  else
    # Make sure we have the latest files.
    e_header "Updating dotfiles"
    cd "$DOTFILES_ROOT"
    git pull
    git submodule update --init --recursive --quiet
  fi

  [[ $noclobber -eq 0 ]] && flags="${flags}c"
  [[ ! $print_link_header -eq 1 ]] ||  [[ ! $print_copy_header ]] && flags="${flags}q"
  [[ $print_help -eq 1 ]] && flags="${flags}h"

  e_header "Executing updated $SCRIPT_NAME script"
  $SCRIPT $flags
  unset flags
  exit 0
}

function intro() {
  echo 'Dotfiles - "Cowboy" Ben Alman - http://benalman.com/'

  if [[ "$1" == "-h" || "$1" == "--help" ]]; then cat <<HELP

Usage: $(basename "$0")

See the README for documentation.
https://github.com/cowboy/dotfiles

Copyright (c) 2012 "Cowboy" Ben Alman
Licensed under the MIT license.
http://benalman.com/about/license/
HELP
  exit; fi
}

# Enough with the functions, let's do stuff.

# Grab command-line options
while getopts ":nscqh" opt
do
  case $opt in
    n)
      new_dotfiles_install="1"
      ;;
    s)
      skip_init="1"
      ;;
    c)
      noclobber="0"
      ;;
    q)
      print_want_header="1"
      print_copy_header="0"
      print_skel_header="0"
      print_link_header="0"
      ;;
    h)
      print_help="0"
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
  esac
done

# Initial stuff; do only if we haven't updated to the newest version
if [[ "$skip_init" -ne "1" ]]; then
  intro $print_help

  e_header "Performing initial configuration"
  # Ensure that we can actually, like, compile anything.
  if ! command -v gcc >/dev/null 2>&1 && [[ "$OSTYPE" =~ ^darwin ]]; then
    e_error "XCode or the Command Line Tools for XCode must be installed first."
    exit 1
  fi
  e_header
  # If Git is not installed, install it (Ubuntu only, since Git comes standard
  # with recent XCode or CLT)
  if ! command -v git >/dev/null 2>&1; then
    e_header "Installing Git"
    # The second or-clause is a cludge -- on Arch, packer won't be installed yet, so $PKG_INSTALL is
    # not going to work.
    if ! $PKG_INSTALL install git || sudo pacman -S git || $PKG_INSTALL git-core; then
        e_error "Git should be installed. It isn't. Aborting."
        exit 1
    fi
  fi

  # Update existing sudo time stamp if set, otherwise do nothing.
  while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &

  # Initialize.
  e_header "Pulling in updated dotfiles repo"
  init_dotfiles
else
  e_header "Skipping initialization"
fi

# Source some utilities & helpers.
source "$DOTFILES_ROOT"/source/10_misc.sh

[[ "$noclobber" -eq "1" ]] && e_header "Preserving some existing configurations"

# Add binaries into the path
PATH=$DOTFILES_ROOT/bin:$PATH
export PATH

# Tweak file globbing.
shopt -s dotglob
shopt -s nullglob

# Create caches directory, if it doesn't already exist.
mkdir -p "$DOTFILES_ROOT/caches"

# If backups are needed, this is where they'll go.
backup_dir="$DOTFILES_ROOT/backups/$(date "+%Y_%m_%d-%H_%M_%S")/"
backup=

# Execute code for each file in these subdirectories.
do_stuff "init"
do_stuff "want"
do_stuff "cpan"
do_stuff "copy"
do_stuff "skel"
do_stuff "link"
process_opt_dirs

# Alert if backups were made.
if [[ "$backup" ]]; then
  echo -e "\nBackups were moved to ~/${backup_dir#$HOME/}"
fi

# Lest I forget to do a few additional things...
if [[ "$new_dotfiles_install" -eq "1" && -e "conf/firsttime_reminder.sh" ]]; then
  e_header "This is a new installation"
  e_header "First-Time Reminders"
  source "conf/firsttime_reminder.sh"
fi

# All done!
e_header "All done!"
