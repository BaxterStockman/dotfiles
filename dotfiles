#!/usr/bin/env bash

# Copyright (c) 2012 "Cowboy" Ben Alman
# With modifications by Matt Schreiber (c) 2015
# Licensed under the MIT license.
# http://benalman.com/about/license/

DOTFILES_VERSION=0.0.1

DOTFILES_PATH="${BASH_SOURCE[0]:-"${HOME}/.dotfiles/bin/dotfiles"}"
DOTFILES_DIRNAME="${DOTFILES_PATH%/*}"
DOTFILES_BASENAME="${DOTFILES_PATH##*/}"
DOTFILES_NAME=dotfiles

if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
    printf '%s: %s\n' "$DOTFILES_NAME" 'cannot be sourced'
    unset DOTFILES_PATH DOTFILES_DIRNAME DOTFILES_BASENAME DOTFILES_NAME
    return 1
else
    declare -grx DOTFILES_PATH DOTFILES_DIRNAME DOTFILES_BASENAME DOTFILES_NAME
fi

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Function definitions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# General utility functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
can_run () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    type -P -- "$@" &>/dev/null
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
truthy () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    case "${*,,}" in
        1|yes|true|on|enable)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Logging stuff
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

init_logging () {
    local -a colors=(RED GREEN BLUE YELLOW MAGENTA CYAN WHITE)

    unset RESET BOLD "${colors[@]}" 2>/dev/null

    if [[ -t 2 ]] && truthy "${DOTFILES_USE_COLOR:-true}"; then
        if can_run tput && tput setaf 0 &>/dev/null; then
            RESET="$(tput sgr0)"
            BOLD="$(tput bold)"
            RED="$(tput setaf 1)"
            GREEN="$(tput setaf 2)"
            YELLOW="$(tput setaf 3)"
            BLUE="$(tput setaf 4)"
            MAGENTA=$(tput setaf 5)
            CYAN=$(tput setaf 6)
            WHITE=$(tput setaf 7)
        else
            RESET="\e[0m"
            BOLD="\e[1m"
            RED="\e[31m"
            GREEN="\e[32m"
            YELLOW="\e[33m"
            BLUE="\e[34m"
            MAGENTA="\e[35m"
            CYAN="\e[36m"
            WHITE="\e[37m"
        fi
    else
        for color in RESET BOLD "${colors[@]}"; do
            declare -grx "${color}="
        done
    fi

    declare -grx RESET BOLD "${colors[@]}"

    if can_run gettext; then
        export TEXTDOMAIN='dotfiles'
        export TEXTDOMAINDIR="${TEXTDOMAINDIR:=/usr/share/locale}"
    else
        # If we can't run `gettext`, just print all the arguments back
        gettext () { echo -n "$@"; }
    fi

    e_header () { printf -- "${BOLD}${WHITE}:: ${RESET}${BOLD}%b${RESET}\n" "$@"; }
    e_prompt () { printf -- "${BOLD}${CYAN} > ${RESET}${BOLD}%b${RESET}: " "$@"; }
    e_success () { printf -- "${GREEN}==> ${RESET}${BOLD} %b${RESET}\n" "$@"; }
    e_warning () { printf -- "${YELLOW}==> $(gettext "WARNING")${RESET}:${BOLD} %b${RESET}\n" "$@"; }
    e_error () { printf -- "${MAGENTA}==> $(gettext "ERROR")${RESET}:${BOLD} %b${RESET}\n" "$@"; }
    e_fatal () { printf -- "${BOLD}${RED}==> $(gettext "FATAL")${RESET}:${BOLD} %b${RESET}\n" "$@"; }
    e_arrow () { printf -- "   ${BLUE}->${RESET}${BOLD} %b${RESET}\n" "$@"; }
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
md5cmp () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Minimize dependencies: cmp is in diffutils, md5sum is in coreutils.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local left="$1"
    shift
    local right="$1"

    local leftsumout rightsumout

    leftsumout="$(md5sum "$left")"
    rightsumout="$(md5sum "$right")"

    # md5sum prints two fields; we're only interested in the leftmost
    [[ "${leftsumout%%[[:space:]]*}" == "${rightsumout%%[[:space:]]*}" ]]
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
splitfile () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local file="$1"
    shift
    local prefix="${1:-}"

    local relpath="${file##$prefix}"

    local -a path_elements
    local IFS=$'/'
    read -ra path_elements <<<"$relpath"
    unset IFS

    # Necessary in order to get rid of the leading trailing space
    printf '%s\n' "${path_elements[*]:1}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
find_hierarchical () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local targetdir="$1"
    shift

    local prefix opt_name opt_arg
    while (( $# )); do
        read -r opt_name opt_arg _ <<<"$@"
        case "$opt_name" in
		-p|--prefix)
			prefix="$opt_arg"
			shift 2
			break
			;;
		*)
			continue
			;;
	esac
    done

    local IFS
    while read -ra path_elements; do
        IFS=$'/'
        printf '%s\n' "${prefix}${prefix:+/}${path_elements[*]}"
        unset IFS
    done < <(sort -n < <(while read -r target; do
        splitfile "$target" "$prefix"
    done < <(find "$targetdir" "$@")))
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_noclobber () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"
    local real_destfile="$destfile"

    if truthy "${DOTFILES_NOCLOBBER:-1}" && [[ -e "$destfile" ]]; then
        local -i noclobber="${DOTFILES_NOCLOBBER_RCS[$destfile]:-0}"

        if (( noclobber )); then
            local noclobber_message
            printf -v noclobber_message -- "Not clobbering %s; s will be appended with '%s'" \
                "$destfile" "$srcfile"  "$DOTFILES_NOCLOBBER_EXT"
            e_arrow "$noclobber_message" 1>&2
            real_destfile="${destfile}${DOTFILES_NOCLOBBER_EXT}"
        fi
    fi

    printf '%s\n' "$real_destfile"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prompt_skip () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Offer the user a chance to skip something.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local REPLY=noskip
    read -t 5 -n 1 -s -r -p "$(e_prompt "To skip, press X within 5 seconds.")"
    if [[ "$REPLY" =~ ^[Xx]$ ]]; then
        echo "Skipping!"
        return 0
    else
        echo "Continuing..."
        return 1
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
backup () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local destfile="$1"

    # Destination file already exists. Back it up!
    if [[ -e "$destfile" ]]; then
        e_arrow "Backing up ${destfile}."
        # Set backup flag, so a nice message can be shown at the end.
        ((__DOTFILES_BACKUP++))

        backup_subpath="${DOTFILES_BACKUPDIR}/${destfile%/*}"
        # Create backup dir if it doesn't already exist.
        if ! [[ -e "$backup_subpath" ]]; then
            if ! mkdir -p "$backup_subpath" &>/dev/null; then
                e_fatal "Could not create backup directory ${backup_subpath}" 1>&2
                return 1
            fi
        elif ! [[ -d "$backup_subpath" ]]; then
            e_error "${backup_subpath} exists but is not a directory" 1>&2
            return 1
        fi

        cp "$destfile" "$backup_subpath"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
call_conditional () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if declare -F "$1" &>/dev/null; then
        "$@"
    else
        # If a submodule doesn't define a function, we don't want to bomb out.
        return 0
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prep_process () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optype_file="$1"
    shift

    # Silently ignore any files that don't define 'run'
    if ! declare -F run &>/dev/null; then
        return 0
    fi

    if [[ -z "${optype-}" ]]; then
        if [[ -n "${processdir-}" ]]; then
            optype="${processdir##*/}"
        else
            local optype_file_basename="${optype_file##*/}"
            local optype_file_noext="${optype_file_basename%.*}"

            # Assume that the filename (minus extension) is of the form
            # [0-9]*_blah
            optype="${optype_file_noext#[[:digit:]]*_}"
        fi
    fi

    # If processdir contains a leading slash, treat it as an absolute path.
    # Otherwise, assume we're looking for a relative path in DOTFILES_ROOT.
    local prefix_path=${DOTFILES_PREFIX:-}${DOTFILES_PREFIX:+/}
    local srcdir
    if [[ "${processdir:-}" =~ ^/ ]]; then
        srcdir="${prefix_path}${processdir}"
    else
        if [[ -z "$optype" ]]; then
            e_error "No operation specified" 1>&2
            return 1
        fi
        srcdir="${DOTFILES_ROOT}/${prefix_path}${optype}"
    fi

    local include_pattern exclude_pattern
    if (( ${#DOTFILES_INCLUDES[@]} )); then
        for include_pattern in "${DOTFILES_INCLUDES[@]}"; do
            if ! [[ "$optype" =~ $include_pattern ]]; then
                e_arrow "Operation '${optype}' does not match include filter; skipping..." 1>&2
                return 1
            fi
        done
    fi

    if (( ${#DOTFILES_EXCLUDES[@]} )); then
        for exclude_pattern in "${DOTFILES_EXCLUDES[@]}"; do
            if [[ "$optype" =~ $exclude_pattern ]]; then
                e_arrow "Operation '${optype}' matches exclude filter; skipping..." 1>&2
                return 1
            fi
        done
    fi

    echo "$srcdir" "$optype"
}

process_check () {
    local srcfile="$1"
    shift
    local destfile="$1"
    shift

    # If _test function returns a string, skip file and print that
    # message.
    local skip_reason
    skip_reason="$(call_conditional check "$srcfile" "$destfile")"
    check_exit_code=$?
    skip_reason="${skip_reason:-unknown error}"

    case "$check_exit_code" in
        0)
            return 0
            ;;
        1)
            e_error "Skipping ${srcstem}: ${skip_reason}" 1>&2
            return 1
            ;;
        2)
            e_arrow "Skipping ${srcstem}: ${skip_reason}" 1>&2
            return 2
            ;;
        *)
            e_fatal "Invalid exit status; exiting."
            exit 1
            ;;
    esac
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
process () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optype_file="$1"
    shift

    # Unset these functions in case the sourced file doesn't define them.
    # Otherwise, some previously-defined function could run.
    unset processdir header optype
    unset -f check run pre post

    if [[ -f "$optype_file" ]]; then
        # Silence "Can't follow non-constant source" warning
        # shellcheck disable=SC1090
        source "$optype_file" "$@" &>/dev/null
        local -i sourced_exit=$?
        if (( sourced_exit != 0 )); then
            e_error "Sourcing ${optype_file} exited abnormally" 1>&2
            return $sourced_exit
        fi
    else
        e_error "No such file: $optype_file" 1>&2
        return 1
    fi

    # Print a pretty header :)
    local header="${header:-"Running ${optype_file}"}"
    e_header "$header"

    read -r srcdir optype _ < <(prep_process "$optype_file")
    local -i prep_exit=$?
    (( prep_exit != 0 )) && return $prep_exit

    local installs_files="${installs_files:-true}"
    if ! [[ -d "$srcdir" ]] && truthy "$installs_files"; then
        if ! (( DOTFILES_IGNORE_MISSING )); then
            e_error "No such directory: $srcdir; unable to complete '$optype' task" 1>&2
        fi
        return 1
    fi

    local skip_reason
    skip_reason="$(call_conditional skip)"
    if [[ -n "$skip_reason" ]]; then
        e_arrow "Skipping ${optype}: ${skip_reason}"
    fi

    call_conditional pre

    local -i failed=0
    if ! truthy "$installs_files"; then
        if ! run; then
            ((failed++))
            ((__DOTFILES_FAILED++))
        fi
    else
        # Iterate over files.
        local skip_reason srcfile srcstem destfile backup_subpath
        local -i check_exit_code
        while read -r srcfile; do
            # Don't quite know why this is necessary -- 'find' sometimes strips the
            # leading slash when called using process substitution...  Because find
            # returns absolute paths, it's probably (?) safe to just append a
            # leading slash.
            [[ "$srcfile" =~ ^/ ]] || srcfile="/${srcfile}"

            srcstem="${srcfile#$srcdir/}"
            destfile="${DOTFILES_DESTDIR}/${srcstem}"

            process_check "$srcfile" "$destfile" || {
                [[ $? == 2 ]] && continue
                destfile="$(check_noclobber "$srcfile" \
                    "${DOTFILES_DESTDIR}/${srcstem}")"
                if ! process_check "$srcfile" "$destfile"; then
                    continue
                fi
            }

            # Only back up the file if we're going to replace it
            backup "$destfile"

            # Do stuff.
            if ! run "$srcfile" "$destfile"; then
                ((failed++))
                ((__DOTFILES_FAILED++))
            fi
        done < <(find_hierarchical "$srcdir" --prefix "$DOTFILES_ROOT" -xtype f)
    fi

    call_conditional post

    (( failed == 0 ))
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
process_all () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# The center of it all.  Runs through the files in DOTFILES_RUNDIR looking for
# stuff to do.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local rundir="$1"
    shift

    local run_extension=".sh"

    local optype_file
    local -i exit_code=0
    for optype_file in "${rundir}/"*"${run_extension}"; do
        # Run in subshell so that the current environment is not affected by
        # any changes the sourced code might make.
        ( process "$optype_file" "$@" ) || (( exit_code |= $? ))
    done

    return $exit_code
}

check_repo_url () {
    local wanted_url="$1"
    shift
    local gitdir="$1"
    shift

    local git_config_path="${gitdir}/.git/config"
    local url_from_config=''
    url_from_config="$(git config --file "$git_config_path" --get remote.origin.url 2>/dev/null)"

    [[ "$wanted_url" == "$url_from_config" ]]
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_dotfiles() {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    e_header "Performing initial configuration"

    if ! type -P git &>/dev/null; then
        e_fatal "git should be installed.  It isn't"
        exit 1
    fi

    # Initialize.
    e_header "Pulling in updated dotfiles repo"

    # Skip this function after we exec the updated version of this script.
    export DOTFILES_SKIP_INIT=1

    if ! check_repo_url "$DOTFILES_CONFIG_REPO" "$DOTFILES_ROOT"; then
        # If the run directory doesn't exist, treat this as a new
        # installation.
        export DOTFILES_NEW_INSTALL=1
        e_header "Downloading dotfiles configuration"
        mkdir -p "$DOTFILES_ROOT"
        if ! git clone --recursive "$DOTFILES_CONFIG_REPO" "$DOTFILES_ROOT"; then
            e_fatal "Cannot clone dotfiles config repo; exiting"
            exit 1
        fi
    else
        # Make sure we have the latest files.
        e_header "Updating dotfiles configuration"
        pushd "$DOTFILES_ROOT" >/dev/null
        git pull || :
        popd >/dev/null
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
usage () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -i return_code=${1:-0}

    printf '%s %s\n' "$DOTFILES_NAME" "$DOTFILES_VERSION"
    printf -- "$(gettext 'Usage: %s [OPTIONS] [-- [PASSTHRU OPTIONS]]')\n" "$0"

    if (( return_code != 0 )); then
        printf -- "$(gettext "Please run '%s --help' for detailed usage.")\n" "$DOTFILES_NAME"
        return "$return_code"
    fi

    gettext -- "$(printf -- '%s' "\
-n, --new-install       Tell dotfiles that this is a new installation.  Causes
                        dotfiles to print some helpful(?) post-installation
                        tips.

-s, --skip-init         Tell dotfiles to skip certain initialization steps,
                        like updating the dotfiles git repository and checking
                        that dependencies are installed.  WARNING: might cause
                        dotfiles to break in hilarious ways.

-c, --clobber           Tell dotfiles to overwrite configuration files that
                        would otherwise have been preserved.  Under the current
                        settings, dotfiles doesn't clobber:
                        ${!DOTFILES_NOCLOBBER_RCS[*]}

-i, --ignore-missing    When given, dotfiles won't raise an error when looking
                        for the source directory specified in a given file in
                        $DOTFILES_RUNDIR.

-I, --include PATTERN   Tell dotfiles to perform only those action types
                        specified in files in $DOTFILES_RUNDIR that match this
                        pattern.  Accepts a Bash regular expression; may be
                        specified multiple times.

-E, --exclude PATTERN   Tell dotfiles to ignore those action types given in
                        file in  $DOTFILES_RUNDIR that match this pattern.
                        Accepts a Bash regular expression; may be specified
                        multiple times.

-P, --preserve FILE     Tell dotfiles to not overwrite this file.  This option
                        can be given multiple times.

-B, --backup-path PATH  Tell dotfiles where to store backups of existing
                        configurations (currently: ${DOTFILES_BACKUPDIR}).

-C, --cache-path PATH   Cache path for use with certain git submodules
                        (currently: ${DOTFILES_CACHEDIR}).

-R, --rundir PATH       The directory in which dotfiles will search for its
                        marching orders (currently: ${DOTFILES_RUNDIR}).  If
                        the path is relative, it's assumed to be relative to
                        DOTFILES_ROOT. See README.md for details.

-X, --bindir PATH       The directory where dotfiles itself will be checked out

-v, --verbose           Tell dotfiles to be chatty.

-q, --quiet             Tell dotfiles to pipe down, guldarnit!

-h, --help              Print this message.

If $DOTFILES_NAME sees a bare '--', it assumes that options processing is
done and passes any further parameters to the scripts in ${DOTFILES_RUNDIR}.
")"

    return "$return_code"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
compare_versions () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local left="$1"
    local right="$2"

    IFS=$'.' read -ra left_elems <<<"$left"
    IFS=$'.' read -ra right_elems <<<"$right"

    local left_elem right_elem
    local r=''
    for i in "${!left_elems[@]}"; do
        left_elem="${left_elems[$i]}"
        right_elem="${right_elems[$i]}"

        (( left_elem == right_elem )) && continue
        if (( left_elem < right_elem )); then
            r="-1"
            return 0
        fi
        r="1"
        return 0
    done

    printf '%s\n' "$r"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_bash_version () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (( BASH_VERSINFO[0] < 3 )); then
        printf -- "$(gettext '%s: You are using an ancient Bash version (%s).  Please upgrade')" \
            "$DOTFILES_NAME" "$BASH_VERSION"
        return 1
    elif (( BASH_VERSINFO[0] < 4 )); then
        printf -- "$(gettext '%s: Your Bash version (%s) does not support associative arrays. Please upgrade.')" \
            "$DOTFILES_NAME" "$BASH_VERSION"
        return 1
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
to_env_var () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optname="$1"
    shift
    local header="$1"

    case "$header" in
        env)
            header=''
            ;;
        '')
            header=DOTFILES
            ;;
        *)
            header="DOTFILES_${header^^}"
            ;;
    esac

    printf '%s' "${header:+${header}_}${optname}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parseconf () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local conf_file="$1"
    shift

    if (( $# )); then
        # Need to assign outer-scope $@ to account for scope change inside
        # `formatter`
        local -a _formatter=("$@")
        formatter () {
            "${_formatter[@]}" "$@"
        }
    else
        formatter () {
            echo -n "${2:+${2}_}${1}"
        }
    fi

    local -i using_extglob=0
    if shopt extglob >/dev/null; then
        using_extglob=1
    else
        shopt -s extglob
    fi

    extract_header () {
        local line="$1"
        shift

        if [[ "$line" == '['*']' ]]; then
            header="${line#[}"
            header="${header%]}"
            if [[ -n $header ]]; then
                echo "$header"
                return 0
            fi
        fi

        return 1
    }

    local optname='' optval='' header=''
    while read -r line; do
        [[ -z "$line" ]] && continue

        # If we got a header, skip to the next iteration
        maybe_header="$(extract_header "$line")" && {
            header="$maybe_header"
            continue
        }

        IFS=$'=' read -r optname optval <<<"$line"
        optname="$(formatter "$optname" "$header")"

        declare -gx "${optname}=${optval}"
    done < "$conf_file"

    unset -f formatter

    (( using_extglob )) || shopt -u extglob
}

init_vars () {
    # Use readlink's -m option (--canonicalize-missing) since we might be on a
    # bootstrap run where DOTFILES_DIRNAME doesn't actually exist yet.
    DOTFILES_ROOT="${DOTFILES_ROOT:-$(readlink -m "${DOTFILES_DIRNAME}/..")}"
    if [[ -z "${DOTFILES_ROOT}" ]]; then
        DOTFILES_ROOT="${HOME}/.dotfiles"
    fi
    declare -gx DOTFILES_ROOT

    # Globals
    declare -gx DOTFILES_BACKUPDIR="${DOTFILES_BACKUPDIR:-${DOTFILES_ROOT}/backup/$(date "+%Y_%m_%d-%H_%M_%S")}"
    declare -gx DOTFILES_CACHEDIR="${DOTFILES_CACHEDIR:-${DOTFILES_ROOT}/caches}"
    declare -gx DOTFILES_DESTDIR="${DOTFILES_DESTDIR:-$HOME}"
    declare -gx DOTFILES_BINDIR="${DOTFILES_BINDIR:-"$DOTFILES_ROOT/bin"}"
    declare -gx DOTFILES_RUNDIR="${DOTFILES_RUNDIR:-"${DOTFILES_ROOT}/run"}"
    declare -gx DOTFILES_CONFIG_REPO="${DOTFILES_CONFIG_REPO:-git://github.com/BaxterStockman/dotfiles-config.git}"
    declare -gx DOTFILES_NOCLOBBER_EXT="${DOTFILES_NOCLOBBER_EXT:-.custom}"

    # Values that are false by default
    for varname in DOTFILES_NEW_INSTALL DOTFILES_SKIP_INIT DOTFILES_IGNORE_MISSING; do
        declare -gx "${varname}=${!varname:-0}"
    done

    # Values that are true by default
    for varname in DOTFILES_NOCLOBBER DOTFILES_VERBOSE; do
        declare -gx "${varname}=${!varname:-1}"
    done

    if [[ "$(< /etc/issue)" =~ ^Arch[[:space:]]+Linux ]]; then
        declare -gx DOTFILES_OSTYPE='arch'
    elif [[ "$OSTYPE" =~ ^darwin ]]; then
        declare -gx DOTFILES_OSTYPE='darwin'
    else
        declare -gx DOTFILES_OSTYPE='linux'
    fi

    declare -gxi __DOTFILES_BACKUP=0
    declare -gxi __DOTFILES_FAILED=0

    declare -gA DOTFILES_NOCLOBBER_RCS=()
    # RC files to not clobber when linking
    if (( ${#DOTFILES_NOCLOBBER_RCS[@]} == 0 )); then
        DOTFILES_NOCLOBBER_RCS=(
            ["${DOTFILES_DESTDIR}/.bashrc"]=1
            ["${DOTFILES_DESTDIR}/.bash_login"]=1
            ["${DOTFILES_DESTDIR}/.bash_logout"]=1
            ["${DOTFILES_DESTDIR}/.bash_profile"]=1
            ["${DOTFILES_DESTDIR}/.muttrc"]=1
            ["${DOTFILES_DESTDIR}/.subversion"]=1
            ["${DOTFILES_DESTDIR}/.perlbrew"]=1
            ["${DOTFILES_DESTDIR}/.ssh"]=1
        )
    fi

    declare -ga DOTFILES_INCLUDES=()
    declare -ga DOTFILES_EXCLUDES=()
}

init_conf () {
    IFS=$':' read -ra dotfiles_extra_envpaths <<<"${DOTFILESENV:-}"
    local -a DOTFILES_ENVPATHS=(
        "${dotfiles_extra_envpaths[@]}"
        /etc/dotfiles.conf
        "${XDG_CONFIG_HOME:-${HOME}/.config}/dotfiles/dotfiles.conf"
        "${HOME}/.dotfilesrc"
    )
    unset dotfiles_extra_envpaths

    for envfile in "${DOTFILES_ENVPATHS[@]}"; do
        if [[ -f "$envfile" ]]; then
            parseconf "$envfile" to_env_var
        fi
    done
}

init_opts () {
    (( ${#optv[@]} )) || return

    set -- "${optv[@]}"

    # Now process new options.
    while (( $# )); do
        case "$1" in
            --)
                shift
                break
                ;;
            -n|--new-install)
                DOTFILES_NEW_INSTALL=1
                ;;
            -s|--skip-init)
                DOTFILES_SKIP_INIT=1
                ;;
            -i|--ignore-missing)
                DOTFILES_IGNORE_MISSING=1
                ;;
            -c|--clobber)
                DOTFILES_NOCLOBBER=0
                ;;
            -P|--preserve)
                DOTFILES_NOCLOBBER_RCS[$2]=1
                shift
                ;;
            -I|--include)
                DOTFILES_INCLUDES+=("$2")
                shift
                ;;
            -E|--exclude)
                DOTFILES_EXCLUDES+=("$2")
                shift
                ;;
            -R|--rundir)
                if [[ "$2" == /* ]]; then
                    DOTFILES_RUNDIR="$2"
                else
                    DOTFILES_RUNDIR="${DOTFILES_ROOT}/$2"
                fi

                shift
                ;;
            -X|--bindir)
                DOTFILES_BINDIR="$2"
                shift
                ;;
            -B|--backup-path)
                DOTFILES_BACKUPDIR="$2"
                shift
                ;;
            -C|--cache-path)
                DOTFILES_CACHEDIR="$2"
                shift
                ;;
            -v|--verbose)
                DOTFILES_VERBOSE=1
                ;;
            -q|--quiet)
                DOTFILES_VERBOSE=0
                ;;
            -h|--help)
                usage 0
                exit $?
                ;;
            *)
                echo "Invalid option: $1" 1>&2
                usage 1
                exit $?
                ;;
        esac

        shift
    done

    optv=("$@")
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    check_bash_version || return $?

    init_vars
    init_conf

    declare -a optv=("$@")
    init_opts
    set -- "${optv[@]}"

    init_logging

    # Don't allow unset variables or uncaught errors
    set -o nounset
    set -o errexit

    # Tweak file globbing.
    shopt -s dotglob
    shopt -s nullglob

    truthy "$DOTFILES_NOCLOBBER"

    # Initial stuff; do only if we haven't updated to the newest version
    if truthy "$DOTFILES_SKIP_INIT"; then
        e_header "Skipping initialization"
    else
        init_dotfiles
    fi

    if truthy "$DOTFILES_NOCLOBBER"; then
        e_header "Preserving some existing configurations"
    fi

    PATH="${DOTFILES_BINDIR}${PATH:+:}${PATH}"
    export PATH

    # Create caches directory, if it doesn't already exist.
    mkdir -p "$DOTFILES_CACHEDIR"

    # Execute code for each file in these subdirectories.
    if [[ -d "$DOTFILES_RUNDIR" ]]; then
        process_all "$DOTFILES_RUNDIR" "$@" || :
    else
        e_fatal "No such directory: ${DOTFILES_RUNDIR} ${DOTFILES_NAME} cannot proceed." 1>&2
        exit 1
    fi

    # Alert if backups were made.
    if (( "$__DOTFILES_BACKUP" > 0 )); then
        e_arrow "Backups were moved to ${DOTFILES_BACKUPDIR}"
    fi

    # All done!
    return $__DOTFILES_FAILED
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Main body of dotfiles
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

main "$@"
