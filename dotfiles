#!/usr/bin/env bash

# dotfiles - an extensible framwork for managing your configuration files
# Copyright (c) 2015 Matt Schreiber
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# dotfiles grew out of the script of the same name written by "Cowboy" Ben
# Alman (https://github.com/cowboy/dotfiles).  The original dotfiles is
# licensed as follows:
#
#   Copyright (c) 2012 "Cowboy" Ben Alman
#   Licensed under the MIT license.
#   http://benalman.com/about/license/
#

# The parseopts() function was adapted from the function of the same name in #
# the makepkg script, part of the pacman distribution
# (https://www.archlinux.org/pacman/).  In addition, the various logging
# functions were adapted from, inter alia, makepkg's msg(), msg2(), and
# warn().  makepkg is licensed as follows:
#
#   makepkg - make packages compatible for use with pacman
#   Generated from makepkg.sh.in; do not edit by hand.
#
#   Copyright (c) 2006-2014 Pacman Development Team <pacman-dev@archlinux.org>
#   Copyright (c) 2002-2006 by Judd Vinet <jvinet@zeroflux.org>
#   Copyright (c) 2005 by Aurelien Foret <orelien@chez.com>
#   Copyright (c) 2006 by Miklos Vajna <vmiklos@frugalware.org>
#   Copyright (c) 2005 by Christian Hamar <krics@linuxforum.hu>
#   Copyright (c) 2006 by Alex Smith <alex@alex-smith.me.uk>
#   Copyright (c) 2006 by Andras Voroskoi <voroskoi@frugalware.org>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

export DOTFILES_VERSION=0.0.2
export DOTFILES_PATH="${BASH_SOURCE[0]:-"${HOME}/.dotfiles/bin/dotfiles"}"
export DOTFILES_DIRNAME="${DOTFILES_PATH%/*}"
export DOTFILES_BASENAME="${DOTFILES_PATH##*/}"
export DOTFILES_NAME=dotfiles

if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
    if [[ "${AUTOMATED_TESTING:-0}" -ne 1 ]]; then
        printf '%s: %s\n' "$DOTFILES_NAME" 'cannot be sourced' 1>&2
        unset DOTFILES_VERSION DOTFILES_PATH DOTFILES_DIRNAME DOTFILES_BASENAME DOTFILES_NAME 2>/dev/null
        return 1
    fi
else
    # Don't allow unset variables or uncaught errors, and don't mask the return
    # value of piped commands.
    set -o nounset
    set -o errexit
    set -o pipefail
fi

# TODO(mschreiber) See if there is a good way to do logging that won't
# prohibit colored output to the terminal OR print a bunch of escape
# characters to the log file.
#exec > >(tee -i -a dotfiles.log)
#exec 2> >(tee -i -a dotfiles.log >&2)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Variable declarations
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Pattens to match against destination files to not clobber when linking.  This
# has to be declared at the global scope because, within a function, `declare'
# == `local' unless you use the `-g' flag, which isn't available before Bash
# 4.2.
DOTFILES_NOCLOBBER_RE=()

# Patterns to match against operation types.
DOTFILES_INCLUDE_RE=() DOTFILES_EXCLUDE_RE=()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Function definitions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# General utility functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
can_run () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    type -P -- "$@" &>/dev/null
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
truthy () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    case "${*,,}" in
        1|y|yes|true|on|enable)
            return "$DOTFILES_EX_OK"
            ;;
        0|n|no|false|off|disable)
            return "$DOTFILES_EX_FAIL"
            ;;
        *)
            return "$DOTFILES_EX_SOFTWARE"
            ;;
    esac
}

if ! can_run cmp; then
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    cmp () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Minimize dependencies: cmp is in diffutils, md5sum is in coreutils.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        local left="$1"
        shift
        local right="$1"

        # md5sum prints two fields; we're only interested in the leftmost
        local leftsum rightsum
        read -r leftsum _ < <(md5sum "$left")
        read -r rightsum _ < <(md5sum "$right")

        [[ "$leftsum" == "$rightsum" ]]
    }
fi

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
splitfile () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local file="$1"
    shift
    local prefix="${1:-}"

    local relpath="${file##$prefix}"

    local -a path_elements
    IFS=$'/' read -ra path_elements <<<"$relpath"

    # Necessary in order to get rid of the leading trailing space
    printf '%s\n' "${path_elements[*]:1}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
find_hierarchical () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local targetdir="$1"
    shift

    local prefix opt_name opt_arg
    while (( $# )); do
        read -r opt_name opt_arg _ <<<"$@"
        case "$opt_name" in
            -p|--prefix)
                prefix="$opt_arg"
                shift 2
                break
                ;;
            *)
                continue
                ;;
	esac
    done

    local IFS
    while read -ra path_elements; do
        IFS=$'/'
        printf '%s\n' "${prefix}${prefix:+/}${path_elements[*]}"
        unset IFS
    done < <(sort -n < <(while read -r target; do
        splitfile "$target" "$prefix"
    done < <(find "$targetdir" "$@")))
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
call_conditional () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -a maybe_funcnames=()

    while (( $# )) && [[ "$1" != '--' ]]; do
        maybe_funcnames+=("$1")
        shift
    done

    shift

    for maybe_funcname in "${maybe_funcnames[@]}"; do
        if declare -F -- "$maybe_funcname" &>/dev/null; then
            "$maybe_funcname" "$@"
            return $?
        fi
    done

    # If a submodule doesn't define a function, we don't want to bomb out.
    return "$DOTFILES_EX_OK"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
call_libfunc () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local funcname="$1"
    shift
    local optype="$1"
    shift

    call_conditional "$funcname" "${optype}::${funcname}" -- "$@"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_repo_url () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local wanted_url="$1"
    shift
    local gitdir="$1"
    shift

    local git_config_path="${gitdir}/.git/config"
    local url_from_config=''
    url_from_config="$(git config --file "$git_config_path" --get remote.origin.url 2>/dev/null)"

    [[ "$wanted_url" == "$url_from_config" ]]
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_bash_version () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (( BASH_VERSINFO[0] < 3 )); then
        printf -- "$(gettext '%s: You are using an ancient Bash version (%s).  Please upgrade')" \
            "$DOTFILES_NAME" "$BASH_VERSION"
        return "$DOTFILES_EX_FAIL"
    elif (( BASH_VERSINFO[0] < 4 )); then
        printf -- "$(gettext '%s: Your Bash version (%s) does not support associative arrays. Please upgrade.')" \
            "$DOTFILES_NAME" "$BASH_VERSION"
        return "$DOTFILES_EX_FAIL"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prompt_skip () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Offer the user a chance to skip something.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local REPLY=noskip
    read -t 5 -n 1 -s -r -p "$(prompt "To skip, press X within 5 seconds.")"
    if [[ "$REPLY" =~ ^[Xx]$ ]]; then
        echo "Skipping!"
        return "$DOTFILES_EX_OK"
    else
        echo "Continuing..."
        return "$DOTFILES_EX_FAIL"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Logging stuff
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

if can_run gettext; then
    export TEXTDOMAIN='dotfiles'
    export TEXTDOMAINDIR="${TEXTDOMAINDIR:=/usr/share/locale}"
else
    # If we can't run `gettext`, just print all the arguments back
    gettext () { echo -n "$@"; }
fi

diag () {
    printf -- '%s: %s' "$DOTFILES_NAME" "$(gettext -- "$@")"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_logging () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -a colors=(RED GREEN BLUE YELLOW MAGENTA CYAN WHITE)

    unset RESET BOLD "${colors[@]}" 2>/dev/null
    export RESET BOLD "${colors[@]}"

    if [[ -t 2 ]] && truthy "${DOTFILES_USE_COLOR:-true}"; then
        if can_run tput && tput setaf 0 &>/dev/null; then
            RESET="$(tput sgr0)"
            BOLD="$(tput bold)"
            RED="$(tput setaf 1)"
            GREEN="$(tput setaf 2)"
            YELLOW="$(tput setaf 3)"
            BLUE="$(tput setaf 4)"
            MAGENTA="$(tput setaf 5)"
            CYAN="$(tput setaf 6)"
            WHITE="$(tput setaf 7)"
        else
            RESET="\e[0m"
            BOLD="\e[1m"
            RED="\e[31m"
            GREEN="\e[32m"
            YELLOW="\e[33m"
            BLUE="\e[34m"
            MAGENTA="\e[35m"
            CYAN="\e[36m"
            WHITE="\e[37m"
        fi
    else
        for color in RESET BOLD "${colors[@]}"; do
            eval "${color}=''"
        done
    fi

    # shellcheck disable=SC2163
    export RESET BOLD "${colors[@]}"

    title () { printf -- "${BOLD}${WHITE}:: ${RESET}${BOLD}%b${RESET}\n" "$@" 1>&2; }
    prompt () { printf -- "${BOLD}${CYAN} > ${RESET}${BOLD}%b${RESET}: " "$@" 1>&2; }
    msg () { printf -- "${GREEN}==> ${RESET}${BOLD} %b${RESET}\n" "$@" 1>&2; }
    msg2 () { printf -- "   ${BLUE}->${RESET}${BOLD} %b${RESET}\n" "$@" 1>&2; }
    warning () { printf -- "${YELLOW}==> $(gettext "WARNING")${RESET}:${BOLD} %b${RESET}\n" "$@" 1>&2; }
    error () { printf -- "${MAGENTA}==> $(gettext "ERROR")${RESET}:${BOLD} %b${RESET}\n" "$@" 1>&2; }
    fatal () { printf -- "${BOLD}${RED}==> $(gettext "FATAL")${RESET}:${BOLD} %b${RESET}\n" "$@" 1>&2; }
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_noclobber () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"
    local real_destfile="$destfile"

    if truthy "${DOTFILES_NOCLOBBER:-1}" && [[ -e "$destfile" ]]; then
        local pattern=''
        for pattern in "${DOTFILES_NOCLOBBER_RE[@]}"; do
            if [[ "$destfile" =~ $pattern ]]; then
                local noclobber_message
                printf -v noclobber_message -- "%s matches preservation filter; filename will be appended with '%s'" \
                    "$destfile" "$srcfile"  "$DOTFILES_NOCLOBBER_EXT"
                msg2 "$noclobber_message"
                real_destfile="${destfile}.${DOTFILES_NOCLOBBER_EXT}"
            fi
        done
    fi

    printf '%s' "$real_destfile"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
backup () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local destfile="$1"

    # Destination file already exists. Back it up!
    if [[ -e "$destfile" ]]; then
        msg2 "Backing up ${destfile}"
        # Set backup flag, so a nice message can be shown at the end.
        (( __DOTFILES_BACKUP += 1 ))

        backup_subpath="${DOTFILES_BACKUPDIR}/${destfile%/*}"
        # Create backup dir if it doesn't already exist.
        if ! [[ -e "$backup_subpath" ]]; then
            if ! mkdir -p "$backup_subpath" &>/dev/null; then
                error "Could not create backup directory ${backup_subpath}"
                return "$DOTFILES_EX_CANTCREAT"
            fi
        elif ! [[ -d "$backup_subpath" ]]; then
            error "${backup_subpath} exists but is not a directory"
            return "$DOTFILES_EX_CANTCREAT"
        fi

        cp "$destfile" "$backup_subpath"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
process_prep () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optype_file="$1"
    shift

    if [[ -z "${optype-}" ]]; then
        if [[ -n "${processdir-}" ]]; then
            optype="${processdir##*/}"
        else
            local optype_file_basename="${optype_file##*/}"
            local optype_file_noext="${optype_file_basename%.*}"

            # Assume that the filename (minus extension) is of the form
            # [0-9]*_blah
            optype="${optype_file_noext#[[:digit:]]*_}"
        fi
    fi

    # Silently ignore any files that don't define 'run'
    if ! { declare -F -- run || declare -F -- "${optype}::run" ; } &>/dev/null; then
        return "$DOTFILES_EX_OK"
    fi

    # If processdir contains a leading slash, treat it as an absolute path.
    # Otherwise, assume we're looking for a relative path in DOTFILES_ROOT.
    local prefix_path=${DOTFILES_PREFIX:-}${DOTFILES_PREFIX:+/}
    local srcdir
    if [[ "${processdir:-}" =~ ^/ ]]; then
        srcdir="${prefix_path}${processdir}"
    else
        if [[ -z "$optype" ]]; then
            error "No operation specified"
            return "$DOTFILES_EX_USAGE"
        fi
        srcdir="${DOTFILES_ROOT}/${prefix_path}${optype}"
    fi

    local -i exclude=0
    if (( ${#DOTFILES_EXCLUDE_RE[@]} )); then
        for exclude_pattern in "${DOTFILES_EXCLUDE_RE[@]}"; do
            if [[ "$optype" =~ $exclude_pattern ]]; then
                warning "Operation '${optype}' matches exclude filter; skipping"
                return 1
            fi
        done
    fi

    local include_pattern exclude_pattern
    # shellcheck disable=SC2043
    for _ in _; do
        if (( ${#DOTFILES_INCLUDE_RE[@]} )); then
            for include_pattern in "${DOTFILES_INCLUDE_RE[@]}"; do
                if [[ "$optype" =~ $include_pattern ]]; then
                    break 2
                fi
            done

            warning "Operation '${optype}' does not match any include filter; skipping..."
            return 1
        fi
    done

    echo "$srcdir" "$optype"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
process_check () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    shift
    local destfile="$1"
    shift
    local optype="$1"

    # If _test function returns a string, skip file and print that
    # message.
    local skip_reason
    skip_reason="$(call_libfunc check "$optype" "$srcfile" "$destfile")"
    check_exit_code=$?
    skip_reason="${skip_reason:-unknown error}"

    case "$check_exit_code" in
        $DOTFILES_EX_OK)
            :
            ;;
        $DOTFILES_EX_TEMPFAIL)
            msg2 "Skipping ${srcstem}: ${skip_reason}"
            ;;
        *)
            if (( check_exit_code != DOTFILES_EX_FAIL )) \
              && (( check_exit_code <= DOTFILES_EX__BASE )) \
              || (( check_exit_code >= DOTFILES_EX__MAX )); then
                error "Invalid exit status"
                check_exit_code="$DOTFILES_EX_PROTOCOL"
            else
                error "Skipping ${srcstem}: ${skip_reason}"
            fi
            ;;
    esac

    return "$check_exit_code"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
process () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optype_file="$1"
    shift

    # Unset these functions in case the sourced file doesn't define them.
    # Otherwise, some previously-defined function could run.
    local -a varnames=(processdir header optype requires_source)
    local -a funcnames=(check run pre post)
    unset "${varnames[@]}"
    unset -f "${funcnames[@]}"

    if [[ -f "$optype_file" ]]; then
        # shellcheck disable=SC1090
        source "$optype_file" -- "$@" &>/dev/null
        local -i sourced_exit=$?
        if (( sourced_exit != 0 )); then
            error "sourcing ${optype_file} exited abnormally"
            return "$sourced_exit"
        fi
    else
        error "no such file: $optype_file"
        return "$DOTFILES_EX_NOINPUT"
    fi

    read -r srcdir optype _ < <(process_prep "$optype_file")
    local -i prep_exit=$?
    (( prep_exit != 0 )) && return $prep_exit

    # Initialize variables
    for varname in "${varnames[@]}"; do
        [[ -z "${!varname:-}" ]] && declare "${varname}=$(call_conditional "${optype}::${varname}")"
    done

    # Print a pretty header :)
    title "${header:-Running ${optype_file}}"

    local requires_source="${requires_source:-true}"
    if ! [[ -d "$srcdir" ]] && truthy "$requires_source"; then
        if ! (( DOTFILES_IGNORE_MISSING )); then
            error "no such directory: ${srcdir}; unable to complete '$optype' task"
        fi
        return "$DOTFILES_EX_NOINPUT"
    fi

    call_libfunc pre "$optype" "$@"

    local -i failed=0
    if ! truthy "$requires_source"; then
        if ! run; then
            ((failed++))
            ((__DOTFILES_FAILED+=1))
        fi
    else
        # Iterate over files.
        local skip_reason srcfile srcstem destfile backup_subpath
        local -i check_exit_code

        # Don't clobber standard input, since sourced scripts may want to do
        # stuff like get user input.
        exec 3< <(find_hierarchical "$srcdir" --prefix "$DOTFILES_ROOT" -xtype f)
        while read -u 3 -r srcfile; do
            # Don't quite know why this is necessary -- 'find' sometimes strips the
            # leading slash when called using process substitution...  Because find
            # returns absolute paths, it's probably (?) safe to just append a
            # leading slash.
            [[ "$srcfile" =~ ^/ ]] || srcfile="/${srcfile}"

            srcstem="${srcfile#$srcdir/}"
            destfile="$(check_noclobber "$srcfile" "${DOTFILES_DESTDIR}/${srcstem}")"

            process_check "$srcfile" "$destfile" "$optype" || continue

            # Only back up the file if we're going to replace it
            backup "$destfile"

            # Do stuff.
            if ! call_libfunc run "$optype" "$srcfile" "$destfile"; then
                ((failed++))
                ((__DOTFILES_FAILED+=1))
            fi
        done

        exec 3<&-
    fi

    call_libfunc post "$optype" "$@"

    (( failed == 0 ))
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
process_all () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# The center of it all.  Runs through the files in DOTFILES_RUNDIR looking for
# stuff to do.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local rundir="$1"
    shift

    local run_extension=".sh"

    local optype_file
    local -i exit_code=0
    for optype_file in "${rundir}/"*"${run_extension}"; do
        # Run in subshell so that the current environment is not affected by
        # any changes the sourced code might make.
        ( process "$optype_file" "$@" ) || (( exit_code |= $? ))
    done

    return $exit_code
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Configuration file parsing
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
to_env_var () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optname="$1"
    shift
    local optval="$1"
    shift
    local header="$1"

    case "$header" in
        env)
            header=''
            ;;
        '')
            header=DOTFILES
            ;;
        *)
            header="DOTFILES_${header^^}"
            ;;
    esac

    # Only set the variable if it is not already set
    env_var="${header:-}${header:+_}${optname^^}"
    if [[ -z ${!env_var+x} ]]; then
        echo "${env_var}=${optval}"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parseconf () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local conf_file="$1"
    shift

    if (( $# )); then
        # Need to assign outer-scope $@ to account for scope change inside
        # `formatter`
        local -a _formatter=("$@")
        formatter () {
            "${_formatter[@]}" "$@"
        }
    else
        formatter () {
            echo "${3:+${3}_}${1}=${2}"
        }
    fi

    local -i using_extglob=0
    if shopt extglob >/dev/null; then
        using_extglob=1
    else
        shopt -s extglob
    fi

    local optname='' optval='' header=''
    # shellcheck disable=SC1090
    source <(while read -r line; do
        if [[ -z "$line" ]] || [[ "$line" =~ [[:space:]]*'#' ]]; then
            continue
        fi

        # If we got a header, skip to the next iteration
        if [[ "$line" == '['*']' ]]; then
            header="${line#[}"
            header="${header%]}"
            if [[ -n $header ]]; then
                continue
            fi
        fi

        IFS=$'=' read -r optname optval <<<"$line"
        formatter "$optname" "$optval" "$header"
    done < "$conf_file")

    unset -f formatter

    (( using_extglob )) || shopt -u extglob
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# CLI options parsing
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
test_varname () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local varname="$1"

    # `unset` exits cleanly even if one of its arguments is not a valid
    # identifier.  Since there won't be any output when `unset` was successful,
    # testing for a non-empty string is a satisfactory indicator of a
    # problematic $optvname value.
    local unset_out=''
    unset_out="$(builtin unset -v "$varname" 2>&1)"
    if [[ -n "$unset_out" ]]; then
        printf -- "$(gettext '%s: `%s'"'"': not a valid identifier\n')" \
            "$DOTFILES_NAME" "$varname"
        return "$DOTFILES_EX_FAIL"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parseopts () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optvname=''
    local -a optspecv=() optaccum=() rest=()

    # We'll be doing a lot of string processing; make sure that the controlling
    # environment doesn't muck things up :)
    local IFS=

    if (( $# < 2 )); then
        printf -- "$(gettext '%s: usage: %s SPEC1 [SPECS] OPTNAME [-- OPTIONS]')" \
            "$DOTFILES_NAME" "$FUNCNAME"
        return "$DOTFILES_EX_USAGE"
    fi

    # Accumulate all options prior to the last option before '--', which is the
    # name of the variable that will be 'returned' to the caller.
    while (( $# > 1 )) && [[ "$2" != '--' ]]; do
        optspecv+=("$1")
        shift
    done

    # Set 'returned' variable name, empty it out, and remove the '--'
    # end-of-options signifier
    optvname="$1"
    test_varname "$optvname" || return $?
    unset -v "$optvname" || return "$DOTFILES_EX_FAIL"
    shift 2

    local -A shortoptmap=()
    local -A longoptmap=()

    local -i hasarg=0 lastind=0
    local opt=''
    for spec in "${optspecv[@]}"; do
        IFS=$'|' read -ra specv <<<"$spec"

        lastind="$(( ${#specv[@]} - 1 ))"
        if [[ "${specv[lastind]}" == *: ]]; then
            hasarg=1
            specv[lastind]="${specv[lastind]%:}"
        fi

        for opt in "${specv[@]}"; do
            if ! [[ "$opt" =~ ^[[:alnum:]] ]]; then
                printf -- "$(gettext '%s: option specification `%s'"'"' is not valid\n')" \
                    "$DOTFILES_NAME" "$opt"
                return "$DOTFILES_EX_USAGE"
            fi
            if (( ${#opt} == 1 )); then
                shortoptmap[$opt]="$hasarg"
            else
                longoptmap[$opt]="$hasarg"
            fi
        done

        hasarg=0
    done

    matchprefix () {
        local opt="$1"
        shift
        local optname="$1"

        test_varname "$optname" || return $?
        unset -v "$optname" || return "$DOTFILES_EX_SOFTWARE"

        local -a matches=()

        for longopt in "${!longoptmap[@]}"; do
            if [[ "$longopt" == "$opt" ]]; then
                matches=("$longopt")
                break
            elif [[ "$longopt" == "$opt"* ]]; then
                matches+=("$longopt")
            fi
        done

        case "${#matches[@]}" in
            0)
                eval "${optname}=${opt}"
                return "${DOTFILES_EX_USAGE}"
                ;;
            1)
                eval "${optname}=${matches[0]}"
                return 0
                ;;
            *)
                printf -- "$(gettext '%s: option `%s'"'"' has multiple matches:\n')" \
                    "$DOTFILES_NAME" "$opt" 1>&2
                printf ' %s' "${matches[@]}" 1>&2
                echo 1>&2
                return "${DOTFILES_EX_TEMPFAIL}"
                ;;
        esac
    }

    validopt () {
        local opt="$1"

        # N.B. Don't limit to integers, as empty string defaults to 0.
        local is_mapped=''
        if (( "${#opt}" > 1 )); then
            is_mapped="${longoptmap["$opt"]:-}"
        else
            is_mapped="${shortoptmap["$opt"]:-}"
        fi

        case "$is_mapped" in
            0|1)
                return "$is_mapped"
                ;;
            *)
                return "$DOTFILES_EX_USAGE"
                ;;
        esac
    }

    local -i success="$DOTFILES_EX_OK"
    local opt='' optarg='' fullopt=''
    while (( $# )); do
        case "$1" in
            --)
                shift
                break
                ;;
            # Short options.
            -[!-]*)
                # Read option one character at a time - bundled options may
                # come this way
                for (( i=1 ; i < ${#1} ; i++ )); do
                    opt="${1:i:1}"
                    optaccum+=("-${opt}")

                    validopt "$opt" && ret=$? || ret=$?
                    case $ret in
                        1)
                            # Assume that the rest of the option is an argument
                            if (( i == 1 )) && [[ -n "${1:2}" ]]; then
                                optaccum+=("${1:i+1}")
                                break
                            elif (( i == ${#1} - 1 )) && [[ -n "${2+x}" ]] && [[ "$2" != -* ]]; then
                                optaccum+=("$2")
                                shift
                                break
                            else
                                printf -- "$(gettext '%s: option `-%s'"'"' requires an argument\n')" \
                                    "$DOTFILES_NAME" "$opt" 1>&2
                                success="$DOTFILES_EX_USAGE"
                                break 2
                            fi
                            ;;
                        0)
                            :
                            ;;
                        *)
                            printf -- "$(gettext '%s: option `-%s'"'"' is not valid\n')" \
                                "$DOTFILES_NAME" "$opt" 1>&2
                            success="$DOTFILES_EX_USAGE"
                            break 2
                            ;;
                    esac
                done
                ;;
            # Long options.
            --?*=*|--?*)
                IFS=$'=' read -r opt optarg <<< "${1#--}"

                matchprefix "$opt" fullopt && ret=$? || ret=$?
                if (( ret == DOTFILES_EX_TEMPFAIL )); then
                    success="$ret"
                    break 2
                fi

                optaccum+=("--${fullopt}")

                validopt "$fullopt" && ret=$? || ret=$?
                case $ret in
                    1)
                        if [[ -n "${optarg:-}" ]]; then
                            optaccum+=("${optarg}")
                        elif [[ -n "${2+x}" ]] && [[ "$2" != -* ]]; then
                            optaccum+=("$2")
                            shift
                        else
                            printf -- "$(gettext '%s: option `--%s'"'"' requires an argument\n')" \
                                "$DOTFILES_NAME" "$opt" 1>&2
                            success="$DOTFILES_EX_USAGE"
                            break 2
                        fi
                        ;;
                    0)
                        if [[ -n "${optarg:+x}" ]]; then
                            printf -- "$(gettext '%s: option `--%s'"'"' does not accept an argument\n')" \
                                "$DOTFILES_NAME" "$opt" 1>&2
                            success="$DOTFILES_EX_USAGE"
                            break 2
                        fi
                        ;;
                    *)
                        printf -- "$(gettext '%s: option `--%s'"'"' is not valid\n')" \
                            "$DOTFILES_NAME" "$opt" 1>&2
                        success="$DOTFILES_EX_USAGE"
                        break 2
                        ;;
                esac
                ;;
            *) # non-option arg encountered, add it as a parameter
                rest+=("$1")
                ;;
        esac
        shift
    done

    if (( success == DOTFILES_EX_OK )); then
        optaccum+=(--)
        (( ${#rest[@]} )) && optaccum+=("${rest[@]}")
        optaccum+=("$@")

        # Yuck.  All this to avoid using `declare -g`...
        # Get the declaration for $optaccum, then remove everything before the
        # opening parenthesis and everything after the closing parenthesis.
        tmpdeclare=''
        tmpdeclare="$(declare -p optaccum)"
        tmpdeclare="${tmpdeclare#*\'}"
        tmpdeclare="${tmpdeclare%\'}"
        eval "${optvname}=${tmpdeclare}"
    fi

    unset -f matchprefix validopt
    return "$success"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Function library for use in the scripts that dotfiles sources
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# System initialization
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init::header () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    printf '%s' 'Running initialization files'
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init::pre () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    :
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init::check () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    :
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init::run () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    title "Sourcing ${srcfile}"
    # shellcheck disable=SC1090
    source "$srcfile"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init::post () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    :
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Copying files
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy::header () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    printf '%s' "Copying files into ${DOTFILES_DESTDIR}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy::pre () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    :
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy::check () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Ensures that files in the destination aren't overwritten if either
#   - The destination file is exactly the same as the source file; or
#   - The destination file is newer than the source file.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"

    if [[ -e "${destfile}" ]]; then
        if cmp "${srcfile}" "${destfile}"; then
            echo "same file"
            return "$DOTFILES_EX_TEMPFAIL"
        elif [[ "${srcfile}" -ot "${destfile}" ]]; then
            echo "destination file newer"
            return "$DOTFILES_EX_TEMPFAIL"
        fi
    fi

    return "$DOTFILES_EX_OK"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy::run () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Attempts to copy a file, printing pretty output
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"
    local destdir="${destfile%/*}"

    if ! mkdir -p "$destdir" >/dev/null; then
        error "can't copy ${srcfile} to ${destfile} - failed to create ${destdir}"
        return "$DOTFILES_EX_CANTCREAT"
    fi

    if ! cp "$srcfile" "$destfile"; then
        error "failed to copy ${srcfile} to ${destfile}"
        return "$DOTFILES_EX_CANTCREAT"
    else
        msg "copied ${srcfile} to ${destfile}"
        return "$DOTFILES_EX_OK"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy::post () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    :
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Copying skeleton files
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skel::header () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    printf '%s' "Copying skeleton files into ${DOTFILES_DESTDIR}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skel::pre () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    :
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skel::check () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# More restrictive than copy_test: if the destination file exists at all, don't
# overwrite it.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local destfile="$2"

    if [[ -e "$destfile" ]]; then
        echo "file exists"
        return "$DOTFILES_EX_TEMPFAIL"
    fi

    return "$DOTFILES_EX_OK"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skel::run () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    copy::run "$@"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
skel::post () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    :
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Linking files
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
link::header () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    printf '%s' "Linking files into ${DOTFILES_DESTDIR}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
link::pre () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    :
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
link::check () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"

    if [[ -e "${destfile}" ]]; then
        if [[ "${srcfile}" -ef "${destfile}" ]]; then
            echo "link already exists"
            return "$DOTFILES_EX_TEMPFAIL"
        else
            echo "${destfile} exists but is not a link"
            return "$DOTFILES_EX_CANTCREAT"
        fi
    fi

    return "$DOTFILES_EX_OK"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
link::run () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"
    local destdir="${destfile%/*}"

    if ! mkdir -p "$destdir" >/dev/null; then
        error "can't link ${destfile} to ${srcfile} - failed to create ${destdir}"
        return "$DOTFILES_EX_CANTCREAT"
    fi

    if ! ln -sf "$srcfile" "$destfile"; then
        error "failed to link ${srcfile} to ${destfile}"
    else
        msg "linked ${srcfile} to ${destfile}"
        return "$DOTFILES_EX_OK"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
link::post () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    :
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Optional configuration
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
opt::header () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    printf '%s' 'Processing optional configuration'
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
opt::pre () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    DOTFILES_IGNORE_MISSING=1
    local dir=''
    for dir in "$srcdir"/*; do
        read -t 10 -n 1 -r -s -p "$(prompt "Process files in ${dir}? [y/N]")"
        if [[ "$REPLY" =~ ^[Yy]$ ]]; then
            echo
            DOTFILES_ROOT="$dir" process_all "$DOTFILES_RUNDIR"
        else
            echo "Skipping..."
        fi
    done
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
opt::check () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    :
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
opt::run () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    :
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
opt::post () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    :
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Environment initialization
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_dotfiles_config_repo () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    title "Performing initial configuration"

    if ! type -P git &>/dev/null; then
        error "git should be installed.  It isn't"
        return "$DOTFILES_EX_FAIL"
    fi

    if ! check_repo_url "$DOTFILES_CONFIG_REPO" "$DOTFILES_ROOT"; then
        title "Downloading dotfiles configuration repo"
        mkdir -p "$DOTFILES_ROOT"
        if ! git clone --recursive "$DOTFILES_CONFIG_REPO" "$DOTFILES_ROOT"; then
            error "Cannot download dotfiles configuration repo"
            return "$DOTFILES_EX_FAIL"
        fi
    else
        # Make sure we have the latest files.
        title "Updating dotfiles configuration"
        pushd "$DOTFILES_ROOT" >/dev/null
        git --work-tree "$DOTFILES_ROOT" --git-dir "${DOTFILES_ROOT}/.git" pull || :
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_ex_vars () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if [[ -r /usr/include/sysexits.h ]]; then
        while read -r ex_type ex_code _; do
            eval "export DOTFILES_${ex_type}=${ex_code}"
        done < <(grep -o 'EX_.*[0-9]\+' /usr/include/sysexits.h)
    else
        export \
            DOTFILES_EX_OK=0 \
            DOTFILES_EX__BASE=64 \
            DOTFILES_EX_USAGE=64 \
            DOTFILES_EX_DATAERR=65 \
            DOTFILES_EX_NOINPUT=66 \
            DOTFILES_EX_NOUSER=67 \
            DOTFILES_EX_NOHOST=68 \
            DOTFILES_EX_UNAVAILABLE=69 \
            DOTFILES_EX_SOFTWARE=70 \
            DOTFILES_EX_OSERR=71 \
            DOTFILES_EX_OSFILE=72 \
            DOTFILES_EX_CANTCREAT=73 \
            DOTFILES_EX_IOERR=74 \
            DOTFILES_EX_TEMPFAIL=75 \
            DOTFILES_EX_PROTOCOL=76 \
            DOTFILES_EX_NOPERM=77 \
            DOTFILES_EX_CONFIG=78 \
            DOTFILES_EX__MAX=78
    fi

    export DOTFILES_EX_FAIL=1
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_vars () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    export DOTFILES_ROOT="${DOTFILES_ROOT:-${HOME}/.dotfiles}"

    # Globals
    export DOTFILES_BACKUPDIR="${DOTFILES_BACKUPDIR:-${DOTFILES_ROOT}/backup/$(date "+%Y_%m_%d-%H_%M_%S")}"
    export DOTFILES_DESTDIR="${DOTFILES_DESTDIR:-$HOME}"
    export DOTFILES_RUNDIR="${DOTFILES_RUNDIR:-"${DOTFILES_ROOT}/run"}"
    export DOTFILES_NOCLOBBER_EXT="${DOTFILES_NOCLOBBER_EXT:-custom}"

    # Values that are false by default
    for varname in DOTFILES_SKIP_INIT DOTFILES_IGNORE_MISSING; do
        export "${varname}=${!varname:-0}"
    done

    # Values that are true by default
    for varname in DOTFILES_NOCLOBBER DOTFILES_VERBOSE; do
        export "${varname}=${!varname:-1}"
    done

    if (( ${#DOTFILES_NOCLOBBER_RE[@]} == 0 )); then
        DOTFILES_NOCLOBBER_RE=(
            '\.bashrc$'
            '\.bash_login$'
            '\.bash_logout$'
            '\.bash_profile$'
            '\.muttrc$'
            '\.subversion$'
            '\.perlbrew$'
            '\.ssh$'
        )
    fi

    export __DOTFILES_BACKUP=0
    export __DOTFILES_FAILED=0
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_conf () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -a dotfiles_envpaths=(
        /etc/dotfiles.conf
        "${XDG_CONFIG_HOME:-${HOME}/.config}/dotfiles/dotfiles.conf"
        "${HOME}/.dotfilesrc"
    )

    local dotfiles_extra_envpath=
    local -a dotfiles_extra_envpaths=()
    IFS=$':' read -ra dotfiles_extra_envpaths <<<"${DOTFILES_ENV:-}"
    for (( i = "${#dotfiles_extra_envpaths[@]}" - 1 ; i >= 0 ; i-- )); do
        dotfiles_extra_envpath="${dotfiles_extra_envpaths[i]}"

        if ! [[ -f "$dotfiles_extra_envpath" ]]; then
            printf '%s: %s\n' "${DOTFILES_NAME}" "$(gettext "no such file: $dotfiles_extra_envpath")"
            return "$DOTFILES_EX_NOINPUT"
        fi

        dotfiles_envpaths+=("${dotfiles_extra_envpath}")
    done

    unset dotfiles_extra_envpaths

    for envfile in "${dotfiles_envpaths[@]}"; do
        if [[ -f "$envfile" ]]; then
            parseconf "$envfile" to_env_var
        fi
    done
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_opts () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    (( ${#optv[@]} )) || return "$DOTFILES_EX_OK"

    local -a optspecv=(
        's|skip-init'
        'i|ignore-missing'
        'c|clobber'
        'P|preserve:'
        'I|include:'
        'E|exclude:'
        'R|rundir:'
        'B|backupdir'
        'v|verbose'
        'q|quiet'
        'h|help'
        'printenv'
    )

    parseopts "${optspecv[@]}" parsedv -- "${optv[@]}" || return $?

    # shellcheck disable=SC2154
    set -- "${parsedv[@]}"
    unset parsedv

    # Now process new options.
    while (( $# )); do
        case "$1" in
            --)
                shift
                break
                ;;
            -s|--skip-init)
                DOTFILES_SKIP_INIT=1
                ;;
            -i|--ignore-missing)
                DOTFILES_IGNORE_MISSING=1
                ;;
            -c|--clobber)
                DOTFILES_NOCLOBBER=0
                ;;
            -P|--preserve)
                DOTFILES_NOCLOBBER_RE+=("$2")
                shift
                ;;
            -I|--include)
                DOTFILES_INCLUDE_RE+=("$2")
                shift
                ;;
            -E|--exclude)
                DOTFILES_EXCLUDE_RE+=("$2")
                shift
                ;;
            -R|--rundir)
                if [[ "$2" == /* ]]; then
                    DOTFILES_RUNDIR="$2"
                else
                    DOTFILES_RUNDIR="${DOTFILES_ROOT}/$2"
                fi

                shift
                ;;
            -B|--backupdir)
                DOTFILES_BACKUPDIR="$2"
                shift
                ;;
            -v|--verbose)
                DOTFILES_VERBOSE=1
                ;;
            -q|--quiet)
                DOTFILES_VERBOSE=0
                ;;
            -h|--help)
                usage 0
                exit $?
                ;;
            --printenv)
                {
                    local varname=''
                    for varname in "${!DOTFILES@}"; do
                        if [[ "$(declare -p "${varname}" 2>-)" == declare*a*=* ]]; then
                            echo "${varname}=(${!varname[*]})"
                        elif [[ "$(declare -p "${varname}" 2>-)" == declare*A*=* ]]; then
                            :
                        else
                            echo "${varname}=${!varname:-}"
                        fi
                    done
                } | sort
                exit 0
                ;;
        esac

        shift
    done

    optv=("$@")
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# dotfiles CLI usage
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
usage () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -i return_code="${1:-$DOTFILES_EX_OK}"

    printf '%s %s\n\n' "$DOTFILES_NAME" "$DOTFILES_VERSION"
    printf -- "$(gettext 'Usage: %s [OPTIONS] [-- [PASSTHRU OPTIONS]]')\n" "$DOTFILES_PATH"

    if (( return_code != DOTFILES_EX_OK )); then
        printf -- "$(gettext "Please run '%s --help' for detailed usage.")\n" "$DOTFILES_NAME"
        return "$return_code"
    fi

    gettext -- "$(printf -- '\n%s' "\
-s, --skip-init         Tell dotfiles to skip certain initialization steps,
                        like updating the dotfiles git repository and checking
                        that dependencies are installed.  WARNING: might cause
                        dotfiles to break in hilarious ways.

-c, --clobber           Tell dotfiles to overwrite configuration files that
                        would otherwise have been preserved.  Under the current
                        settings, dotfiles doesn't clobber:
                        ${!DOTFILES_NOCLOBBER_RE[*]}

-i, --ignore-missing    When given, dotfiles won't raise an error when looking
                        for the source directory specified in a given file in
                        $DOTFILES_RUNDIR.

-I, --include PATTERN   Tell dotfiles to perform only those action types
                        specified in files in $DOTFILES_RUNDIR that match this
                        pattern, and only if the action type does not match an
                        --exclude pattern.  Accepts a Bash regular expression;
                        may be specified multiple times.

-E, --exclude PATTERN   Tell dotfiles to ignore those action types given in
                        file in  $DOTFILES_RUNDIR that match this pattern.
                        Accepts a Bash regular expression; may be specified
                        multiple times.  Takes precedence over --include
                        patterns.

-P, --preserve FILE     Tell dotfiles to not overwrite this file.  This option
                        can be given multiple times.

-B, --backupdir PATH    Tell dotfiles where to store backups of existing
                        configurations (currently: ${DOTFILES_BACKUPDIR}).

-R, --rundir PATH       The directory in which dotfiles will search for its
                        marching orders (currently: ${DOTFILES_RUNDIR}).  If
                        the path is relative, it's assumed to be relative to
                        DOTFILES_ROOT. See README.md for details.

-v, --verbose           Tell dotfiles to be chatty.

-q, --quiet             Tell dotfiles to pipe down, guldarnit!

-h, --help              Print this message.

If $DOTFILES_NAME sees a bare '--', it assumes that options processing is
done and passes any further parameters to the scripts in ${DOTFILES_RUNDIR}.
")"
    echo

    return "$return_code"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Main body of dotfiles
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_all () {
    check_bash_version || return $?

    init_ex_vars
    init_conf
    init_vars
    init_opts
    init_logging
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    optv=("$@")
    init_all
    (( ${#optv[@]} )) && set -- "${optv[@]}"

    # Bomb out here if dotfiles source repo is unset
    if [[ -z "${DOTFILES_CONFIG_REPO:-}" ]]; then
        error "No configuration repository provided"
        return "$DOTFILES_EX_CONFIG"
    fi

    # Tweak file globbing.
    shopt -s dotglob
    shopt -s nullglob

    # Initial stuff; do only if we haven't updated to the newest version
    if truthy "$DOTFILES_SKIP_INIT"; then
        title "Skipping initialization"
    else
        init_dotfiles_config_repo
    fi

    if truthy "$DOTFILES_NOCLOBBER"; then
        title "Preserving some existing configurations"
    fi

    # Execute code for each file in these subdirectories.
    if [[ -d "$DOTFILES_RUNDIR" ]]; then
        process_all "$DOTFILES_RUNDIR" "$@" || :
    else
        error "no such directory: ${DOTFILES_RUNDIR}"
        return "$DOTFILES_EX_NOINPUT"
    fi

    # Alert if backups were made.
    if (( "$__DOTFILES_BACKUP" > 0 )); then
        warning "Backups were moved to ${DOTFILES_BACKUPDIR}"
    fi

    # All done!
    return $__DOTFILES_FAILED
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    main "$@"
else
    optv=("$@")
    init_all "$@"
    (( ${#optv[@]} )) && set -- "${optv[@]}"
    unset optv
fi
