#!/usr/bin/env bash

# Copyright (c) 2012 "Cowboy" Ben Alman
# With modifications by Matt Schreiber (c) 2015
# Licensed under the MIT license.
# http://benalman.com/about/license/

SCRIPT_PATH="${BASH_SOURCE[0]:-"${HOME}/.dotfiles/bin/dotfiles"}"
SCRIPT_BASENAME="${SCRIPT_PATH##*/}"
SCRIPT_DIRNAME="${SCRIPT_PATH%/*}"

# Use readlink's -m option (--canonicalize-missing) since we might be on a
# bootstrap run where SCRIPT_DIRNAME doesn't actually exist yet.
export DOTFILES_ROOT="${DOTFILES_ROOT:-$(readlink -m "${SCRIPT_DIRNAME}/..")}"

if [[ -z "${DOTFILES_ROOT}" ]]; then
    export DOTFILES_ROOT="${HOME}/.dotfiles"
fi

# Only enter this block if dotfiles isn't being sourced
if [[ -z "${BASH_SOURCE[*]}" ]] || [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    __DOTFILES_SOURCED=0

    # If DOTFILES_VERSION is already set, we're being exec'd by an older
    # version of dotfiles.
    if [[ -n $DOTFILES_VERSION ]]; then
        DOTFILES_OLD_VERSION="$DOTFILES_VERSION"
    fi

    # Set current version
    DOTFILES_VERSION=1.0.0

    # If __DOTFILES_EXECD == 1 at this point, we know that we have been
    # exec'd with an updated version.  Therefore, if DOTFILES_VERSION was unset
    # until just before now, it's because the script just started running and
    # not because we were exec'd from an old version that didn't yet use
    # DOTFILES_VERSION.  So, set the value of DOTFILES_OLD_VERSION to
    # DOTFILES_VERSION so that check_dotfiles_version doesn't complain.
    if ! (( ${__DOTFILES_EXECD:-0} )); then
        DOTFILES_OLD_VERSION="$DOTFILES_VERSION"
    fi
else
    __DOTFILES_SOURCED=1
fi

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Logging stuff
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
if [[ "$(locale charmap)" =~ UTF-8 ]] && [[ "$TERM" != 'linux' ]] ; then
    e_header ()   {
        printf "\033[1;35m★★★★★\033[0m %b \033[1;35m★★★★★\033[0m\n" "$@"
    }
    e_prompt ()   { printf " \033[1;37m☛\033[0m %b " "$@"; }
    e_success ()  { printf " \033[1;32m✔\033[0m %b\n" "$@"; }
    e_error ()    { printf " \033[1;31m✖\033[0m %b\n" "$@"; }
    e_fatal ()    { printf " \033[1;31m☠\033[0m %b\n" "$@"; }
    e_arrow ()    { printf " \033[1;33m➜\033[0m %b\n" "$@"; }
else
    e_header ()   {
        printf "\033[1;35m=====\033[0m %b \033[1;35m=====\033[0m\n" "$@"
    }
    e_prompt ()   { printf " \033[1;37m?\033[0m %b " "$@"; }
    e_success ()  { printf " \033[1;32m:)\033[0m %b\n" "$@"; }
    e_error ()    { printf " \033[1;31m:(\033[0m %b\n" "$@"; }
    e_fatal ()    { printf " \033[1;31m:/\033[0m %b\n" "$@"; }
    e_arrow ()    { printf " \033[1;33m->\033[0m %b\n" "$@"; }
fi

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
md5cmp () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Minimize dependencies: cmp is in diffutils, md5sum is in coreutils.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local left right leftsumout rightsumout

    left="$1"
    right="$2"

    leftsumout="$(md5sum "$left")"
    rightsumout="$(md5sum "$right")"

    # md5sum prints two fields; we're only interested in the leftmost
    [[ "${leftsumout%%[[:space:]]*}" == "${rightsumout%%[[:space:]]*}" ]]
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
splitfile () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local file="$1"
    local prefix="$2"
    local relpath="${file##$prefix}"
    local -a path_elements
    local IFS=$'/'
    read -ra path_elements <<<"$relpath"
    unset IFS
    # Necessary in order to get rid of the leading trailing space
    echo "${path_elements[@]:1}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
find_hierarchical () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local targetdir="$1"
    shift
    local prefix

    local opt_name opt_arg
    while (( $# )); do
        read -r opt_name opt_arg _ <<<"$@"
        case "$opt_name" in
		-p|--prefix)
			prefix="$opt_arg"
			shift 2
			break
			;;
		*)
			continue
			;;
	esac
    done

    local IFS
    while read -ra path_elements; do
        IFS=$'/'
        echo "${prefix}${prefix:+/}${path_elements[*]}"
        unset IFS
    done < <(sort -n < <(while read -r target; do
        splitfile "$target" "$prefix"
    done < <(find "$targetdir" "$@")))
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_noclobber () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"
    local real_destfile="$destfile"

    if "${DOTFILES_NOCLOBBER}"; then
        [[ -e "$destfile" ]] || return

        local -i noclobber="${DOTFILES_NOCLOBBER_RCS[$destfile]:-0}"

        if (( noclobber )); then
            local noclobber_message
            printf -v noclobber_message %s "Not clobbering ${destfile};" \
                " ${srcfile} will be appended with '${DOTFILES_NOCLOBBER_EXT}'"
            e_arrow "$noclobber_message" 1>&2
            real_destfile="${destfile}${DOTFILES_NOCLOBBER_EXT}"
        fi
    fi

    echo "$real_destfile"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prompt_skip () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Offer the user a chance to skip something.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local REPLY=noskip
    read -t 5 -n 1 -s -p "$(e_prompt "To skip, press X within 5 seconds.")"
    if [[ "$REPLY" =~ ^[Xx]$ ]]; then
        echo "Skipping!"
        return 0
    else
        echo "Continuing..."
        return 1
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
backup () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local destfile="$1"

    # Destination file already exists. Back it up!
    if [[ -e "$destfile" ]]; then
        e_arrow "Backing up ${destfile}."
        # Set backup flag, so a nice message can be shown at the end.
        ((__DOTFILES_BACKUP++))

        backup_subpath="${DOTFILES_BACKUPDIR}/${destfile%/*}"
        # Create backup dir if it doesn't already exist.
        if ! [[ -e "$backup_subpath" ]]; then
            if ! mkdir -p "$backup_subpath" &>/dev/null; then
                e_fatal "Could not create backup directory" \
                    "${backup_subpath}; exiting".
                exit 1
            fi
        elif ! [[ -d "$backup_subpath" ]]; then
            e_error "${backup_subpath} exists but is not a directory" 1>&2
            exit 1
        fi

        cp "$destfile" "$backup_subpath"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
call_conditional () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if declare -F "$1" &>/dev/null; then
        "$@"
    else
        # If a submodule doesn't define a function, we don't want to bomb out.
        return 0
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prep_process () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optype_file="$1"
    shift

    # Silently ignore any operation types that haven't been declared.
    if ! declare -F run &>/dev/null; then
        return 0
    fi

    if [[ -z "${optype-}" ]]; then
        if [[ -n "${processdir-}" ]]; then
            optype="${processdir##*/}"
        else
            local optype_file_basename="${optype_file##*/}"
            local optype_file_noext="${optype_file_basename%.*}"

            # Assume that the filename (minus extension) is of the form
            # [0-9]*_blah
            optype="${optype_file_noext#[[:digit:]]*_}"
        fi
    fi

    # If processdir contains a leading slash, treat it as an absolute path.
    # Otherwise, assume we're looking for a relative path in DOTFILES_ROOT.
    local prefix_path=${DOTFILES_PREFIX:-}${DOTFILES_PREFIX:+/}
    local srcdir
    if [[ "${processdir:-}" =~ ^/ ]]; then
        srcdir="${prefix_path}${processdir}"
    else
        if [[ -z "$optype" ]]; then
            e_error "No operation specified" 1>&2
            return 1
        fi
        srcdir="${DOTFILES_ROOT}/${prefix_path}${optype}"
    fi

    local filter
    if (( ${#DOTFILES_FILTERS[@]} )); then
        for filter in "${DOTFILES_FILTERS[@]}"; do
            if [[ "$srcdir" =~ $filter ]]; then
                e_arrow "Directory ${srcdir} matches filter; skipping..." 1>&2
                return 1
            fi
        done
    fi

    echo "$srcdir" "$optype"
}

process_check () {
    local srcfile="$1"
    shift
    local destfile="$1"
    shift

    # If _test function returns a string, skip file and print that
    # message.
    local skip_reason
    skip_reason="$(call_conditional check "$srcfile" "$destfile")"
    check_exit_code=$?
    skip_reason="${skip_reason:-unknown error}"

    case "$check_exit_code" in
        0)
            return 0
            ;;
        1)
            e_error "Skipping ${srcstem}: ${skip_reason}" 1>&2
            return 1
            ;;
        2)
            e_arrow "Skipping ${srcstem}: ${skip_reason}" 1>&2
            return 2
            ;;
        *)
            e_fatal "Invalid exit status; exiting."
            exit 1
            ;;
    esac
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
process () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optype_file="$1"
    shift

    # Unset these functions in case the sourced file doesn't define them.
    # Otherwise, some previously-defined function could run.
    unset processdir header optype
    unset -f check run pre post

    if [[ -f "$optype_file" ]]; then
        source "$optype_file" "$@" &>/dev/null
        local -i sourced_exit=$?
        if (( sourced_exit != 0 )); then
            e_error "Sourcing ${optype_file} exited abnormally" 1>&2
            return $sourced_exit
        fi
    else
        e_error "No such file: $optype_file" 1>&2
        return 1
    fi

    # Print a pretty header :)
    local header="${header:-"Running ${optype_file}"}"
    e_header "$header"

    read -r srcdir optype _ < <(prep_process "$optype_file")
    local -i prep_exit=$?
    (( prep_exit != 0 )) && return $prep_exit

    if ! [[ -d "$srcdir" ]]; then
        if ! (( DOTFILES_IGNORE_MISSING )); then
            e_error "No such directory: $srcdir;" \
                "unable to complete '$optype' task" 1>&2
        fi
        return 1
    fi

    local skip_reason
    skip_reason="$(call_conditional skip)"
    if [[ -n "$skip_reason" ]]; then
        e_arrow "Skipping ${optype}: ${skip_reason}"
    fi

    call_conditional pre

    # Iterate over files.
    local skip_reason srcfile srcstem destfile backup_subpath
    local -i check_exit_code
    local -i failed=0
    while read -r srcfile; do
        # Don't quite know why this is necessary -- 'find' sometimes strips the
        # leading slash when called using process substitution...  Because find
        # returns absolute paths, it's probably (?) safe to just append a
        # leading slash.
        [[ "$srcfile" =~ ^/ ]] || srcfile="/${srcfile}"

        srcstem="${srcfile#$srcdir/}"
        destfile="${DOTFILES_DESTDIR}/${srcstem}"

        process_check "$srcfile" "$destfile" || {
            [[ $? == 2 ]] && continue
            destfile="$(check_noclobber "$srcfile" \
                "${DOTFILES_DESTDIR}/${srcstem}")"
            if ! process_check "$srcfile" "$destfile"; then
                continue
            fi
        }

        # Only back up the file if we're going to replace it
        backup "$destfile"

        # Do stuff.
        if ! run "$srcfile" "$destfile"; then
            ((failed++))
            ((__DOTFILES_FAILED++))
        fi
    done < <(find_hierarchical "$srcdir" --prefix "$DOTFILES_ROOT" -xtype f)

    call_conditional post

    (( failed == 0 ))
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
process_all () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# The center of it all.  Runs through the files in DOTFILES_RUNDIR looking for
# stuff to do.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local rundir="$1"
    shift

    local run_extension=".sh"

    local optype_file
    local -i exit_code=0
    for optype_file in "${rundir}/"*"${run_extension}"; do
        process "$optype_file" "$@"
        (( exit_code &= $? ))
    done

    return $exit_code
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_dotfiles() {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    intro

    e_header "Performing initial configuration"

    if ! type -P git &>/dev/null; then
        e_fatal "git should be installed.  It isn't"
        exit 1
    fi

    # Initialize.
    e_header "Pulling in updated dotfiles repo"

    # Skip this function after we exec the updated version of this script.
    export DOTFILES_SKIP_INIT=1

    if [[ ! -d $DOTFILES_ROOT ]]; then
        # If the root directory doesn't exist, treat this as a new
        # installation.
        export DOTFILES_NEW_INSTALL=1
        e_header "Downloading dotfiles configuration"
	mkdir -p "$DOTFILES_ROOT"
        git clone --recursive "$DOTFILES_CONFIG_REPO" "$DOTFILES_ROOT"
    else
        # Make sure we have the latest files.
        e_header "Updating dotfiles configuration"
        pushd "$DOTFILES_ROOT" >/dev/null
        git pull
        popd >/dev/null
    fi

    if [[ ! -d "$DOTFILES_BINDIR" ]]; then
        e_header "Downloading dotfiles"
	mkdir -p "$DOTFILES_BINDIR"
        git clone --recursive "$DOTFILES_REPO" "$DOTFILES_BINDIR"
    else
        # Make sure we have the latest dotfiles script
        e_header "Updating dotfiles"
        pushd "$DOTFILES_BINDIR" >/dev/null


        local prev_head
        prev_head="$(git rev-parse HEAD)"

        git pull

        local current_head
        current_head="$(git rev-parse HEAD)"

        popd >/dev/null

        if [[ "$current_head" != "$prev_head" ]]; then
            e_header "Executing updated ${SCRIPT_BASENAME} script"
            export __DOTFILES_EXECD=1
            exec "${DOTFILES_BINDIR}/dotfiles"
        fi
    fi
}

intro () {
    printf '%s' "\

See the README for documentation. https://github.com/BaxterStockman/dotfiles

Copyright (c) 2012 \"Cowboy\" Ben Alman Licensed under the MIT license.
http://benalman.com/about/license/

With modifications copyright (c) 2015 Matt Schreiber under the MIT license.

"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
usage () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -i return_code=${1:-0}

    if (( return_code != 0 )); then
        printf '%s' "
Usage: $SCRIPT_BASENAME [OPTIONS] [-- [PASSTHRU OPTIONS]]

Please run 'dotfiles --help' for detailed usage.
"

        return "$return_code"
    fi

    printf '%s' "\
-n, --new-install       Tell dotfiles that this is a new installation.  Causes
                        dotfiles to print some helpful(?) post-installation
                        tips.

-s, --skip-init         Tell dotfiles to skip certain initialization steps,
                        like updating the dotfiles git repository and checking
                        that dependencies are installed.  WARNING: might cause
                        dotfiles to break in hilarious ways.

-c, --clobber           Tell dotfiles to overwrite configuration files that
                        would otherwise have been preserved.  Under the current
                        settings, dotfiles doesn't clobber:
                        ${!DOTFILES_NOCLOBBER_RCS[*]}

-P, --preserve FILES    Tell dotfiles to preserve a list of files passed as a
                        comma-separated argument.

-B, --backup-path PATH  Tell dotfiles where to store backups of existing
                        configurations (currently: ${DOTFILES_BACKUPDIR}).

-C, --cache-path PATH   Cache path for use with certain git submodules
                        (currently: ${DOTFILES_CACHEDIR}).

-R, --rundir PATH       The directory in which dotfiles will search for its
                        marching orders (currently: ${DOTFILES_RUNDIR}).  If
                        the path is relative, it's assumed to be relative to
                        DOTFILES_ROOT. See README.md for details.

-X, --bindir PATH       The directory where dotfiles itself will be checked out

-v, --verbose           Tell dotfiles to be chatty.

-q, --quiet             Tell dotfiles to pipe it down, guldarnit!

-h, --help              Print this message.

If $SCRIPT_BASENAME sees a bare '--', it assumes that options processing is
done and passes any further parameters to the scripts in ${DOTFILES_RUNDIR}.
"

    return "$return_code"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
compare_versions () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local left="$1"
    local right="$2"

    IFS=$'.' read -ra left_elems <<<"$left"
    IFS=$'.' read -ra right_elems <<<"$right"

    local left_elem right_elem
    for i in "${!left_elems[@]}"; do
        left_elem="${left_elems[$i]}"
        right_elem="${right_elems[$i]}"

        (( left_elem == right_elem )) && continue
        if (( left_elem < right_elem )); then
            echo "-1"
            return 0
        fi
        echo "1"
        return 0
    done

    return 0
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_dotfiles_version () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local comparison
    comparison="$(compare_versions $DOTFILES_VERSION \
        ${DOTFILES_OLD_VERSION:-$DOTFILES_VERSION})"

    if [[ -z "${DOTFILES_OLD_VERSION-}" ]] || (( comparison > 0 )); then
        e_fatal "You are running an old version of dotfiles.  Old options " \
            "may no longer work.  Please run 'dotfiles --help' to view usage."
        exit 1
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
explode_bash_version () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local version_string="$1"
    shift

    local major_ver minor_ver trailing build revision
    IFS=$'.' read -r major_ver minor_ver trailing <<<"$version_string"
    if [[ "$trailing" =~ ([[:digit:]]+)\(([[:digit:]]+)*\) ]]; then
        build="${BASH_REMATCH[1]}"
        revision="${BASH_REMATCH[2]}"
    fi
    echo "$major_ver" "$minor_ver" "$build" "$revision"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_bash_version () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local bash_major_ver
    read -r bash_major_ver _ <<<"$(explode_bash_version "$BASH_VERSION")"

    if (( bash_major_ver < 3 )); then
        e_fatal "You are using an ancient Bash version ($BASH_VERSION)." \
            "Please upgrade."
        exit 1
    elif (( bash_major_ver < 4 )); then
        e_fatal "Your Bash version ($BASH_VERSION) doesn't support" \
            "associative arrays. Please upgrade."
        exit 1
    fi

}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    check_bash_version
    check_dotfiles_version

    local opt_name opt_value
    while (( $# )); do
        read opt_name opt_value _ <<<"$@"
        case "$opt_name" in
            --)
                shift
                break
                ;;
            -n|--new-install)
                DOTFILES_NEW_INSTALL=1
                shift
                ;;
            -s|--skip-init)
                DOTFILES_SKIP_INIT=1
                shift
                ;;
            -c|--clobber)
                DOTFILES_NOCLOBBER=0
                shift
                ;;
            -P|--preserve)
                DOTFILES_NOCLOBBER_RCS[$opt_value]=1
                shift 2
                ;;
            -F|--filter)
                DOTFILES_FILTERS+=("$opt_value")
                shift 2
                ;;
            -R|--rundir)
                if [[ "$opt_value" =~ ^/ ]]; then
                    DOTFILES_RUNDIR="$opt_value"
                else
                    DOTFILES_RUNDIR="${DOTFILES_ROOT}/$opt_value"
                fi

                shift 2
                ;;
            -X|--bindir)
                DOTFILES_BINDIR="$opt_value"
                shift 2
                ;;
            -B|--backup-path)
                DOTFILES_BACKUPDIR="$opt_value"
                shift 2
                ;;
            -C|--cache-path)
                DOTFILES_CACHEDIR="$opt_value"
                shift 2
                ;;
            -v|--verbose)
                DOTFILES_VERBOSE=0
                shift
                ;;
            -q|--quiet)
                DOTFILES_VERBOSE=0
                shift
                ;;
            -h|--help)
                usage 0
                exit $?
                ;;
            *)
                echo "Invalid option: ${opt_name}" 1>&2
                usage 1
                exit $?
                ;;
        esac
    done

    # Initial stuff; do only if we haven't updated to the newest version
    if (( ${DOTFILES_SKIP_INIT:-0} )); then
        init_dotfiles
    else
        e_header "Skipping initialization"
    fi

    "${DOTFILES_NOCLOBBER}" \
        && e_header "Preserving some existing configurations"

    # Add binaries into the path
    PATH="${DOTFILES_BINDIR}${PATH:+:}${PATH}"
    export PATH

    # Create caches directory, if it doesn't already exist.
    mkdir -p "$DOTFILES_CACHEDIR"

    # Execute code for each file in these subdirectories.
    if [[ -d "$DOTFILES_RUNDIR" ]]; then
        process_all "$DOTFILES_RUNDIR" "$@"
    else
        e_fatal "No such directory: ${DOTFILES_RUNDIR}" \
            "${SCRIPT_BASENAME} cannot proceed." 1>&2
        exit 1
    fi

    # Alert if backups were made.
    if (( "$__DOTFILES_BACKUP" > 0 )); then
        e_arrow "Backups were moved to ${DOTFILES_BACKUPDIR}"
    fi

    # All done!
    e_header "All done!"
    return $__DOTFILES_FAILED
}

if ! (( __DOTFILES_SOURCED )); then
    # Don't allow unset variables or uncaught errors
    #set -o nounset

    # Tweak file globbing.
    shopt -s dotglob
    shopt -s nullglob

    # Globals
    export DOTFILES_BACKUPDIR="${DOTFILES_BACKUPDIR:-${DOTFILES_ROOT}/backup/$(date "+%Y_%m_%d-%H_%M_%S")}"
    export DOTFILES_CACHEDIR="${DOTFILES_CACHEDIR:-${DOTFILES_ROOT}/caches}"
    export DOTFILES_DESTDIR="${DOTFILES_DESTDIR:-$HOME}"
    export DOTFILES_BINDIR="${DOTFILES_BINDIR:-"$DOTFILES_ROOT/bin"}"
    export DOTFILES_RUNDIR="${DOTFILES_RUNDIR:-"${DOTFILES_ROOT}/run"}"
    export DOTFILES_REPO="${DOTFILES_REPO:-git://github.com/BaxterStockman/dotfiles.git}"
    export DOTFILES_CONFIG_REPO="${DOTFILES_CONFIG_REPO:-git://github.com/BaxterStockman/dotfiles-config.git}"
    export DOTFILES_NOCLOBBER_EXT="${DOTFILES_NOCLOBBER_EXT:-.custom}"

    # Values that are false by default
    for varname in DOTFILES_NEW_INSTALL DOTFILES_SKIP_INIT DOTFILES_IGNORE_MISSING; do
        current_value="${!varname}"
        if (( ${current_value:-0} == 1 )) || [[ $current_value == value ]]; then
            value=1
        else
            value=0
        fi

        declare -i "${varname}=${value}"
    done

    # Values that are true by default
    for varname in DOTFILES_NOCLOBBER DOTFILES_VERBOSE; do
        current_value="${!varname}"
        if (( ${current_value:-1} == 0 )) || [[ $current_value == false ]]; then
            value=0
        else
            value=1
        fi

        declare -i "${varname}=${value}"
    done

    if [[ "$(< /etc/issue)" =~ ^Arch[[:space:]]+Linux ]]; then
        declare -r DOTFILES_OSTYPE='arch'
    elif [[ "$OSTYPE" =~ ^darwin ]]; then
        declare -r DOTFILES_OSTYPE='darwin'
    else
        declare -r DOTFILES_OSTYPE='linux'
    fi
    export DOTFILES_OSTYPE

    declare -i __DOTFILES_BACKUP=0
    declare -i __DOTFILES_FAILED=0

    declare -A DOTFILES_NOCLOBBER_RCS=()
    # RC files to not clobber when linking
    if (( ${#DOTFILES_NOCLOBBER_RCS[@]} == 0 )); then
        DOTFILES_NOCLOBBER_RCS=(
            ["${DOTFILES_DESTDIR}/.bashrc"]=1
            ["${DOTFILES_DESTDIR}/.bash_login"]=1
            ["${DOTFILES_DESTDIR}/.bash_logout"]=1
            ["${DOTFILES_DESTDIR}/.bash_profile"]=1
            ["${DOTFILES_DESTDIR}/.muttrc"]=1
            ["${DOTFILES_DESTDIR}/.subversion"]=1
            ["${DOTFILES_DESTDIR}/.perlbrew"]=1
            ["${DOTFILES_DESTDIR}/.ssh"]=1
        )
    fi

    declare -a DOTFILES_FILTERS=()

    main "$@"
else
    unset SCRIPT_PATH SCRIPT_BASENAME SCRIPT_DIRNAME
    unset __DOTFILES_SOURCED __DOTFILES_EXECD
    unset -f intro usage
fi

