#!/usr/bin/env bash

# Copyright (c) 2012 "Cowboy" Ben Alman
# With modifications by Matt Schreiber (c) 2015
# Licensed under the MIT license.
# http://benalman.com/about/license/

# Don't allow unset variables or uncaught errors, and don't mask the return
# value of piped commands.
set -o nounset
set -o errexit
set -o pipefail

DOTFILES_VERSION=0.0.1

DOTFILES_PATH="${BASH_SOURCE[0]:-"${HOME}/.dotfiles/bin/dotfiles"}"
DOTFILES_DIRNAME="${DOTFILES_PATH%/*}"
DOTFILES_BASENAME="${DOTFILES_PATH##*/}"
DOTFILES_NAME=dotfiles

if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
    printf '%s: %s\n' "$DOTFILES_NAME" 'cannot be sourced' 1>&2
    unset DOTFILES_PATH DOTFILES_DIRNAME DOTFILES_BASENAME DOTFILES_NAME
    return 1
else
    declare -grx DOTFILES_PATH DOTFILES_DIRNAME DOTFILES_BASENAME DOTFILES_NAME
fi

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Function definitions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# General utility functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
can_run () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    type -P -- "$@" &>/dev/null
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
truthy () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    case "${*,,}" in
        1|yes|true|on|enable)
            return "$DOTFILES_EX_OK"
            ;;
        0|no|false|off|disable)
            return "$DOTFILES_EX_FAIL"
            ;;
        *)
            return "$DOTFILES_EX_SOFTWARE"
            ;;
    esac
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
md5cmp () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Minimize dependencies: cmp is in diffutils, md5sum is in coreutils.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local left="$1"
    shift
    local right="$1"

    # md5sum prints two fields; we're only interested in the leftmost
    local leftsum rightsum
    read -r leftsum _ < <(md5sum "$left")
    read -r rightsum _ < <(md5sum "$right")

    [[ "$leftsum" == "$rightsum" ]]
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
splitfile () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local file="$1"
    shift
    local prefix="${1:-}"

    local relpath="${file##$prefix}"

    local -a path_elements
    local IFS=$'/'
    read -ra path_elements <<<"$relpath"
    unset IFS

    # Necessary in order to get rid of the leading trailing space
    printf '%s\n' "${path_elements[*]:1}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
find_hierarchical () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local targetdir="$1"
    shift

    local prefix opt_name opt_arg
    while (( $# )); do
        read -r opt_name opt_arg _ <<<"$@"
        case "$opt_name" in
		-p|--prefix)
			prefix="$opt_arg"
			shift 2
			break
			;;
		*)
			continue
			;;
	esac
    done

    local IFS
    while read -ra path_elements; do
        IFS=$'/'
        printf '%s\n' "${prefix}${prefix:+/}${path_elements[*]}"
        unset IFS
    done < <(sort -n < <(while read -r target; do
        splitfile "$target" "$prefix"
    done < <(find "$targetdir" "$@")))
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
call_conditional () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if declare -F -- "$1" &>/dev/null; then
        "$@"
    else
        # If a submodule doesn't define a function, we don't want to bomb out.
        return "$DOTFILES_EX_OK"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_repo_url () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local wanted_url="$1"
    shift
    local gitdir="$1"
    shift

    local git_config_path="${gitdir}/.git/config"
    local url_from_config=''
    url_from_config="$(git config --file "$git_config_path" --get remote.origin.url 2>/dev/null)"

    [[ "$wanted_url" == "$url_from_config" ]]
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_bash_version () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if (( BASH_VERSINFO[0] < 3 )); then
        printf -- "$(gettext '%s: You are using an ancient Bash version (%s).  Please upgrade')" \
            "$DOTFILES_NAME" "$BASH_VERSION"
        return "$DOTFILES_EX_FAIL"
    elif (( BASH_VERSINFO[0] < 4 )); then
        printf -- "$(gettext '%s: Your Bash version (%s) does not support associative arrays. Please upgrade.')" \
            "$DOTFILES_NAME" "$BASH_VERSION"
        return "$DOTFILES_EX_FAIL"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prompt_skip () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Offer the user a chance to skip something.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local REPLY=noskip
    read -t 5 -n 1 -s -r -p "$(e_prompt "To skip, press X within 5 seconds.")"
    if [[ "$REPLY" =~ ^[Xx]$ ]]; then
        echo "Skipping!"
        return "$DOTFILES_EX_OK"
    else
        echo "Continuing..."
        return "$DOTFILES_EX_FAIL"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Logging stuff
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_logging () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -a colors=(RED GREEN BLUE YELLOW MAGENTA CYAN WHITE)

    unset RESET BOLD "${colors[@]}" 2>/dev/null

    if [[ -t 2 ]] && truthy "${DOTFILES_USE_COLOR:-true}"; then
        if can_run tput && tput setaf 0 &>/dev/null; then
            RESET="$(tput sgr0)"
            BOLD="$(tput bold)"
            RED="$(tput setaf 1)"
            GREEN="$(tput setaf 2)"
            YELLOW="$(tput setaf 3)"
            BLUE="$(tput setaf 4)"
            MAGENTA=$(tput setaf 5)
            CYAN=$(tput setaf 6)
            WHITE=$(tput setaf 7)
        else
            RESET="\e[0m"
            BOLD="\e[1m"
            RED="\e[31m"
            GREEN="\e[32m"
            YELLOW="\e[33m"
            BLUE="\e[34m"
            MAGENTA="\e[35m"
            CYAN="\e[36m"
            WHITE="\e[37m"
        fi
    else
        for color in RESET BOLD "${colors[@]}"; do
            declare -grx "${color}="
        done
    fi

    declare -grx RESET BOLD "${colors[@]}"

    if can_run gettext; then
        export TEXTDOMAIN='dotfiles'
        export TEXTDOMAINDIR="${TEXTDOMAINDIR:=/usr/share/locale}"
    else
        # If we can't run `gettext`, just print all the arguments back
        gettext () { echo -n "$@"; }
    fi

    e_header () { printf -- "${BOLD}${WHITE}:: ${RESET}${BOLD}%b${RESET}\n" "$@" 1>&2; }
    e_prompt () { printf -- "${BOLD}${CYAN} > ${RESET}${BOLD}%b${RESET}: " "$@" 1>&2; }
    e_success () { printf -- "${GREEN}==> ${RESET}${BOLD} %b${RESET}\n" "$@" 1>&2; }
    e_warning () { printf -- "${YELLOW}==> $(gettext "WARNING")${RESET}:${BOLD} %b${RESET}\n" "$@" 1>&2; }
    e_error () { printf -- "${MAGENTA}==> $(gettext "ERROR")${RESET}:${BOLD} %b${RESET}\n" "$@" 1>&2; }
    e_fatal () { printf -- "${BOLD}${RED}==> $(gettext "FATAL")${RESET}:${BOLD} %b${RESET}\n" "$@" 1>&2; }
    e_arrow () { printf -- "   ${BLUE}->${RESET}${BOLD} %b${RESET}\n" "$@" 1>&2; }
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check_noclobber () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    local destfile="$2"
    local real_destfile="$destfile"

    if truthy "${DOTFILES_NOCLOBBER:-1}" && [[ -e "$destfile" ]]; then
        local -i noclobber="${DOTFILES_NOCLOBBER_RCS[$destfile]:-0}"

        if (( noclobber )); then
            local noclobber_message
            printf -v noclobber_message -- "Not clobbering %s; %s will be appended with '%s'" \
                "$destfile" "$srcfile"  "$DOTFILES_NOCLOBBER_EXT"
            e_arrow "$noclobber_message"
            real_destfile="${destfile}${DOTFILES_NOCLOBBER_EXT}"
        fi
    fi

    printf '%s\n' "$real_destfile"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
backup () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local destfile="$1"

    # Destination file already exists. Back it up!
    if [[ -e "$destfile" ]]; then
        e_arrow "Backing up ${destfile}"
        # Set backup flag, so a nice message can be shown at the end.
        ((__DOTFILES_BACKUP++))

        backup_subpath="${DOTFILES_BACKUPDIR}/${destfile%/*}"
        # Create backup dir if it doesn't already exist.
        if ! [[ -e "$backup_subpath" ]]; then
            if ! mkdir -p "$backup_subpath" &>/dev/null; then
                e_fatal "Could not create backup directory ${backup_subpath}"
                return "$DOTFILES_EX_CANTCREAT"
            fi
        elif ! [[ -d "$backup_subpath" ]]; then
            e_error "${backup_subpath} exists but is not a directory"
            return "$DOTFILES_EX_CANTCREAT"
        fi

        cp "$destfile" "$backup_subpath"
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
process_prep () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optype_file="$1"
    shift

    # Silently ignore any files that don't define 'run'
    if ! declare -F run &>/dev/null; then
        return "$DOTFILES_EX_OK"
    fi

    if [[ -z "${optype-}" ]]; then
        if [[ -n "${processdir-}" ]]; then
            optype="${processdir##*/}"
        else
            local optype_file_basename="${optype_file##*/}"
            local optype_file_noext="${optype_file_basename%.*}"

            # Assume that the filename (minus extension) is of the form
            # [0-9]*_blah
            optype="${optype_file_noext#[[:digit:]]*_}"
        fi
    fi

    # If processdir contains a leading slash, treat it as an absolute path.
    # Otherwise, assume we're looking for a relative path in DOTFILES_ROOT.
    local prefix_path=${DOTFILES_PREFIX:-}${DOTFILES_PREFIX:+/}
    local srcdir
    if [[ "${processdir:-}" =~ ^/ ]]; then
        srcdir="${prefix_path}${processdir}"
    else
        if [[ -z "$optype" ]]; then
            e_error "No operation specified"
            return "$DOTFILES_EX_USAGE"
        fi
        srcdir="${DOTFILES_ROOT}/${prefix_path}${optype}"
    fi

    local include_pattern exclude_pattern
    if (( ${#DOTFILES_INCLUDES[@]} )); then
        for include_pattern in "${DOTFILES_INCLUDES[@]}"; do
            if ! [[ "$optype" =~ $include_pattern ]]; then
                e_arrow "Operation '${optype}' does not match include filter; skipping..."
                return 1
            fi
        done
    fi

    if (( ${#DOTFILES_EXCLUDES[@]} )); then
        for exclude_pattern in "${DOTFILES_EXCLUDES[@]}"; do
            if [[ "$optype" =~ $exclude_pattern ]]; then
                e_arrow "Operation '${optype}' matches exclude filter; skipping"
                return 1
            fi
        done
    fi

    echo "$srcdir" "$optype"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
process_check () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local srcfile="$1"
    shift
    local destfile="$1"
    shift

    # If _test function returns a string, skip file and print that
    # message.
    local skip_reason
    skip_reason="$(call_conditional check "$srcfile" "$destfile")"
    check_exit_code=$?
    skip_reason="${skip_reason:-unknown error}"

    case "$check_exit_code" in
        $DOTFILES_EX_OK)
            :
            ;;
        $DOTFILES_EX_TEMPFAIL)
            e_arrow "Skipping ${srcstem}: ${skip_reason}"
            ;;
        *)
            if (( check_exit_code != DOTFILES_EX_FAIL )) \
              && (( check_exit_code <= DOTFILES_EX__BASE )) \
              || (( check_exit_code >= DOTFILES_EX__MAX )); then
                e_fatal "Invalid exit status"
                check_exit_code="$DOTFILES_EX_PROTOCOL"
            else
                e_error "Skipping ${srcstem}: ${skip_reason}"
            fi
            ;;
    esac

    return "$check_exit_code"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
process () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optype_file="$1"
    shift

    # Unset these functions in case the sourced file doesn't define them.
    # Otherwise, some previously-defined function could run.
    unset processdir header optype
    unset -f check run pre post

    if [[ -f "$optype_file" ]]; then
        # Silence "Can't follow non-constant source" warning
        # shellcheck disable=SC1090
        source "$optype_file" "$@" &>/dev/null
        local -i sourced_exit=$?
        if (( sourced_exit != 0 )); then
            e_error "Sourcing ${optype_file} exited abnormally"
            return "$sourced_exit"
        fi
    else
        e_error "No such file: $optype_file"
        return "$DOTFILES_EX_NOINPUT"
    fi

    # Print a pretty header :)
    local header="${header:-"Running ${optype_file}"}"
    e_header "$header"

    read -r srcdir optype _ < <(process_prep "$optype_file")
    local -i prep_exit=$?
    (( prep_exit != 0 )) && return $prep_exit

    local requires_source="${requires_source:-true}"
    if ! [[ -d "$srcdir" ]] && truthy "$requires_source"; then
        if ! (( DOTFILES_IGNORE_MISSING )); then
            e_error "No such directory: $srcdir; unable to complete '$optype' task"
        fi
        return "$DOTFILES_EX_NOINPUT"
    fi

    local skip_reason
    skip_reason="$(call_conditional skip)"
    if [[ -n "$skip_reason" ]]; then
        e_arrow "Skipping ${optype}: ${skip_reason}"
    fi

    call_conditional pre

    local -i failed=0
    if ! truthy "$requires_source"; then
        if ! run; then
            ((failed++))
            ((__DOTFILES_FAILED++))
        fi
    else
        # Iterate over files.
        local skip_reason srcfile srcstem destfile backup_subpath
        local -i check_exit_code

        # Don't clobber standard input, since sourced scripts may want to do
        # stuff like get user input.
        exec 3< <(find_hierarchical "$srcdir" --prefix "$DOTFILES_ROOT" -xtype f)
        while read -u 3 -r srcfile; do
            # Don't quite know why this is necessary -- 'find' sometimes strips the
            # leading slash when called using process substitution...  Because find
            # returns absolute paths, it's probably (?) safe to just append a
            # leading slash.
            [[ "$srcfile" =~ ^/ ]] || srcfile="/${srcfile}"

            srcstem="${srcfile#$srcdir/}"
            destfile="${DOTFILES_DESTDIR}/${srcstem}"

            process_check "$srcfile" "$destfile" || continue
            #process_check "$srcfile" "$destfile" || {
            #    (( $? == DOTFILES_EX_TEMPFAIL )) && continue

            #    destfile="$(check_noclobber "$srcfile" \
            #        "${DOTFILES_DESTDIR}/${srcstem}")"

            #    process_check "$srcfile" "$destfile" || continue
            #}

            # Only back up the file if we're going to replace it
            backup "$destfile"

            # Do stuff.
            if ! run "$srcfile" "$destfile"; then
                ((failed++))
                ((__DOTFILES_FAILED++))
            fi
        done
    fi

    call_conditional post

    (( failed == 0 ))
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
process_all () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# The center of it all.  Runs through the files in DOTFILES_RUNDIR looking for
# stuff to do.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local rundir="$1"
    shift

    local run_extension=".sh"

    local optype_file
    local -i exit_code=0
    for optype_file in "${rundir}/"*"${run_extension}"; do
        # Run in subshell so that the current environment is not affected by
        # any changes the sourced code might make.
        ( process "$optype_file" "$@" ) || (( exit_code |= $? ))
    done

    return $exit_code
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Configuration file parsing
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
to_env_var () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local optname="$1"
    shift
    local header="$1"

    case "$header" in
        env)
            header=''
            ;;
        '')
            header=DOTFILES
            ;;
        *)
            header="DOTFILES_${header^^}"
            ;;
    esac

    printf '%s' "${header:+${header}_}${optname^^}"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parseconf () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local conf_file="$1"
    shift

    if (( $# )); then
        # Need to assign outer-scope $@ to account for scope change inside
        # `formatter`
        local -a _formatter=("$@")
        formatter () {
            "${_formatter[@]}" "$@"
        }
    else
        formatter () {
            echo -n "${2:+${2}_}${1}"
        }
    fi

    local -i using_extglob=0
    if shopt extglob >/dev/null; then
        using_extglob=1
    else
        shopt -s extglob
    fi

    extract_header () {
        local line="$1"
        shift

        if [[ "$line" == '['*']' ]]; then
            header="${line#[}"
            header="${header%]}"
            if [[ -n $header ]]; then
                echo "$header"
                return "$DOTFILES_EX_OK"
            fi
        fi

        return "$DOTFILES_EX_FAIL"
    }

    local optname='' optval='' header=''
    while read -r line; do
        if [[ -z "$line" ]] || [[ "$line" =~ [[:space:]]*'#' ]]; then
            continue
        fi

        # If we got a header, skip to the next iteration
        maybe_header="$(extract_header "$line")" && {
            header="$maybe_header"
            continue
        }

        IFS=$'=' read -r optname optval <<<"$line"
        optname="$(formatter "$optname" "$header")"

        # Strip leading and trailing quotes
        optval="${optval/#[\'\"]/}"
        optval="${optval/%[\'\"]/}"

        if ! declare -gx "${optname}=${optval}" 2>/dev/null; then
            printf '%s: error declaring %s=%s\n' "$DOTFILES_NAME" "$optname" "$optval" 1>&2
            return "$DOTFILES_EX_DATAERR"
        fi
    done < "$conf_file"

    unset -f formatter

    (( using_extglob )) || shopt -u extglob
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Environment initialization
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_dotfiles_config_repo () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    e_header "Performing initial configuration"

    if ! type -P git &>/dev/null; then
        e_fatal "git should be installed.  It isn't"
        return "$DOTFILES_EX_FAIL"
    fi

    if ! check_repo_url "$DOTFILES_CONFIG_REPO" "$DOTFILES_ROOT"; then
        e_header "Downloading dotfiles configuration repo"
        mkdir -p "$DOTFILES_ROOT"
        if ! git clone --recursive "$DOTFILES_CONFIG_REPO" "$DOTFILES_ROOT"; then
            e_fatal "Cannot download dotfiles configuration repo"
            return "$DOTFILES_EX_FAIL"
        fi
    else
        # Make sure we have the latest files.
        e_header "Updating dotfiles configuration"
        pushd "$DOTFILES_ROOT" >/dev/null
        git --work-tree "$DOTFILES_ROOT" --git-dir "${DOTFILES_ROOT}/.git" pull || :
    fi
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_ex_vars () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if [[ -r /usr/include/sysexits.h ]]; then
        while read -r define ex_type ex_code _; do
            if [[ "$define" != '#define' ]] || [[ "$ex_type" != EX_* ]]; then
                continue
            fi
            declare -girx "DOTFILES_${ex_type}=${ex_code}"
        done < /usr/include/sysexits.h
    else
        declare -girx \
            DOTFILES_EX_OK=0 \
            DOTFILES_EX__BASE=64 \
            DOTFILES_EX_USAGE=64 \
            DOTFILES_EX_DATAERR=65 \
            DOTFILES_EX_NOINPUT=66 \
            DOTFILES_EX_NOUSER=67 \
            DOTFILES_EX_NOHOST=68 \
            DOTFILES_EX_UNAVAILABLE=69 \
            DOTFILES_EX_SOFTWARE=70 \
            DOTFILES_EX_OSERR=71 \
            DOTFILES_EX_OSFILE=72 \
            DOTFILES_EX_CANTCREAT=73 \
            DOTFILES_EX_IOERR=74 \
            DOTFILES_EX_TEMPFAIL=75 \
            DOTFILES_EX_PROTOCOL=76 \
            DOTFILES_EX_NOPERM=77 \
            DOTFILES_EX_CONFIG=78 \
            DOTFILES_EX__MAX=78
    fi

    declare -girx DOTFILES_EX_FAIL=1
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_vars () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    init_ex_vars

    # Use readlink's -m option (--canonicalize-missing) since we might be on a
    # bootstrap run where DOTFILES_DIRNAME doesn't actually exist yet.
    DOTFILES_ROOT="${DOTFILES_ROOT:-$(readlink -m "${DOTFILES_DIRNAME}/..")}"
    if [[ -z "${DOTFILES_ROOT}" ]]; then
        DOTFILES_ROOT="${HOME}/.dotfiles"
    fi
    declare -gx DOTFILES_ROOT

    # Globals
    declare -gx DOTFILES_BACKUPDIR="${DOTFILES_BACKUPDIR:-${DOTFILES_ROOT}/backup/$(date "+%Y_%m_%d-%H_%M_%S")}"
    declare -gx DOTFILES_DESTDIR="${DOTFILES_DESTDIR:-$HOME}"
    declare -gx DOTFILES_RUNDIR="${DOTFILES_RUNDIR:-"${DOTFILES_ROOT}/run"}"
    declare -gx DOTFILES_NOCLOBBER_EXT="${DOTFILES_NOCLOBBER_EXT:-.custom}"

    # Values that are false by default
    for varname in DOTFILES_SKIP_INIT DOTFILES_IGNORE_MISSING; do
        declare -gx "${varname}=${!varname:-0}"
    done

    # Values that are true by default
    for varname in DOTFILES_NOCLOBBER DOTFILES_VERBOSE; do
        declare -gx "${varname}=${!varname:-1}"
    done

    if [[ "$(< /etc/issue)" =~ ^Arch[[:space:]]+Linux ]]; then
        declare -gx DOTFILES_OSTYPE='arch'
    elif [[ "$OSTYPE" =~ ^darwin ]]; then
        declare -gx DOTFILES_OSTYPE='darwin'
    else
        declare -gx DOTFILES_OSTYPE='linux'
    fi

    declare -gxi __DOTFILES_BACKUP=0
    declare -gxi __DOTFILES_FAILED=0

    declare -gA DOTFILES_NOCLOBBER_RCS=()
    # RC files to not clobber when linking
    if (( ${#DOTFILES_NOCLOBBER_RCS[@]} == 0 )); then
        DOTFILES_NOCLOBBER_RCS=(
            ["${DOTFILES_DESTDIR}/.bashrc"]=1
            ["${DOTFILES_DESTDIR}/.bash_login"]=1
            ["${DOTFILES_DESTDIR}/.bash_logout"]=1
            ["${DOTFILES_DESTDIR}/.bash_profile"]=1
            ["${DOTFILES_DESTDIR}/.muttrc"]=1
            ["${DOTFILES_DESTDIR}/.subversion"]=1
            ["${DOTFILES_DESTDIR}/.perlbrew"]=1
            ["${DOTFILES_DESTDIR}/.ssh"]=1
        )
    fi

    declare -ga DOTFILES_INCLUDES=()
    declare -ga DOTFILES_EXCLUDES=()
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_conf () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -a dotfiles_envpaths=(
        /etc/dotfiles.conf
        "${XDG_CONFIG_HOME:-${HOME}/.config}/dotfiles/dotfiles.conf"
        "${HOME}/.dotfilesrc"
    )

    local -a dotfiles_extra_envpaths=()
    IFS=$':' read -ra dotfiles_extra_envpaths <<<"${DOTFILES_ENV:-}"
    for (( i = "${#dotfiles_extra_envpaths[@]}" - 1 ; i >= 0 ; i-- )); do
        dotfiles_envpaths+=("${dotfiles_extra_envpaths[i]}")
    done

    unset dotfiles_extra_envpaths

    for envfile in "${dotfiles_envpaths[@]}"; do
        if [[ -f "$envfile" ]]; then
            parseconf "$envfile" to_env_var
        fi
    done
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
init_opts () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    (( ${#optv[@]} )) || return "$DOTFILES_EX_OK"

    set -- "${optv[@]}"

    # Now process new options.
    while (( $# )); do
        case "$1" in
            --)
                shift
                break
                ;;
            -s|--skip-init)
                DOTFILES_SKIP_INIT=1
                ;;
            -i|--ignore-missing)
                DOTFILES_IGNORE_MISSING=1
                ;;
            -c|--clobber)
                DOTFILES_NOCLOBBER=0
                ;;
            -P|--preserve)
                DOTFILES_NOCLOBBER_RCS[$2]=1
                shift
                ;;
            -I|--include)
                DOTFILES_INCLUDES+=("$2")
                shift
                ;;
            -E|--exclude)
                DOTFILES_EXCLUDES+=("$2")
                shift
                ;;
            -R|--rundir)
                if [[ "$2" == /* ]]; then
                    DOTFILES_RUNDIR="$2"
                else
                    DOTFILES_RUNDIR="${DOTFILES_ROOT}/$2"
                fi

                shift
                ;;
            -B|--backup-path)
                DOTFILES_BACKUPDIR="$2"
                shift
                ;;
            -v|--verbose)
                DOTFILES_VERBOSE=1
                ;;
            -q|--quiet)
                DOTFILES_VERBOSE=0
                ;;
            -h|--help)
                usage 0
                exit $?
                ;;
            *)
                echo "Invalid option: $1" 1>&2
                usage "$DOTFILES_EX_USAGE"
                exit $?
                ;;
        esac

        shift
    done

    optv=("$@")
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# dotfiles CLI usage
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
usage () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    local -i return_code="${1:-$DOTFILES_EX_OK}"

    printf '%s %s\n\n' "$DOTFILES_NAME" "$DOTFILES_VERSION"
    printf -- "$(gettext 'Usage: %s [OPTIONS] [-- [PASSTHRU OPTIONS]]')\n" "$0"

    if (( return_code != DOTFILES_EX_OK )); then
        printf -- "$(gettext "Please run '%s --help' for detailed usage.")\n" "$DOTFILES_NAME"
        return "$return_code"
    fi

    gettext -- "$(printf -- '\n%s' "\
-s, --skip-init         Tell dotfiles to skip certain initialization steps,
                        like updating the dotfiles git repository and checking
                        that dependencies are installed.  WARNING: might cause
                        dotfiles to break in hilarious ways.

-c, --clobber           Tell dotfiles to overwrite configuration files that
                        would otherwise have been preserved.  Under the current
                        settings, dotfiles doesn't clobber:
                        ${!DOTFILES_NOCLOBBER_RCS[*]}

-i, --ignore-missing    When given, dotfiles won't raise an error when looking
                        for the source directory specified in a given file in
                        $DOTFILES_RUNDIR.

-I, --include PATTERN   Tell dotfiles to perform only those action types
                        specified in files in $DOTFILES_RUNDIR that match this
                        pattern.  Accepts a Bash regular expression; may be
                        specified multiple times.

-E, --exclude PATTERN   Tell dotfiles to ignore those action types given in
                        file in  $DOTFILES_RUNDIR that match this pattern.
                        Accepts a Bash regular expression; may be specified
                        multiple times.

-P, --preserve FILE     Tell dotfiles to not overwrite this file.  This option
                        can be given multiple times.

-B, --backup-path PATH  Tell dotfiles where to store backups of existing
                        configurations (currently: ${DOTFILES_BACKUPDIR}).

-R, --rundir PATH       The directory in which dotfiles will search for its
                        marching orders (currently: ${DOTFILES_RUNDIR}).  If
                        the path is relative, it's assumed to be relative to
                        DOTFILES_ROOT. See README.md for details.

-X, --bindir PATH       The directory where dotfiles itself will be checked out

-v, --verbose           Tell dotfiles to be chatty.

-q, --quiet             Tell dotfiles to pipe down, guldarnit!

-h, --help              Print this message.

If $DOTFILES_NAME sees a bare '--', it assumes that options processing is
done and passes any further parameters to the scripts in ${DOTFILES_RUNDIR}.
")"
    echo

    return "$return_code"
}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Main body of dotfiles
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
main () {
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    check_bash_version || return $?

    init_vars
    init_conf

    declare -a optv=("$@")
    init_opts
    set -- "${optv[@]:-}"

    init_logging

    # Bomb out here if dotfiles source repo is unset
    if [[ -z "${DOTFILES_CONFIG_REPO:-}" ]]; then
        e_fatal "No configuration repository provided"
        return "$DOTFILES_EX_CONFIG"
    fi

    # Tweak file globbing.
    shopt -s dotglob
    shopt -s nullglob

    truthy "$DOTFILES_NOCLOBBER"

    # Initial stuff; do only if we haven't updated to the newest version
    if truthy "$DOTFILES_SKIP_INIT"; then
        e_header "Skipping initialization"
    else
        init_dotfiles_config_repo
    fi

    if truthy "$DOTFILES_NOCLOBBER"; then
        e_header "Preserving some existing configurations"
    fi

    # Execute code for each file in these subdirectories.
    if [[ -d "$DOTFILES_RUNDIR" ]]; then
        process_all "$DOTFILES_RUNDIR" "$@" || :
    else
        e_fatal "No such directory: ${DOTFILES_RUNDIR}"
        return "$DOTFILES_EX_NOINPUT"
    fi

    # Alert if backups were made.
    if (( "$__DOTFILES_BACKUP" > 0 )); then
        e_arrow "Backups were moved to ${DOTFILES_BACKUPDIR}"
    fi

    # All done!
    return $__DOTFILES_FAILED
}

main "$@"
